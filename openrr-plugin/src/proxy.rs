//! This module defines FFI-safe equivalents of the various types and traits
//! used in arci and openrr-plugin. The types defined by this module will never
//! appear in the public API, and the conversion is done internally.

#![allow(clippy::let_unit_value)] // this lint is triggered for code generated by #[sabi_trait]
#![allow(clippy::unnecessary_cast)] // this lint is triggered for code generated by #[sabi_trait]

#[rustfmt::skip]
#[path = "gen/proxy.rs"]
mod impls;

use std::{sync::Arc, time::SystemTime};

use abi_stable::{
    StableAbi, declare_root_module_statics,
    library::RootModule,
    package_version_strings,
    prefix_type::PrefixTypeTrait,
    rtry, sabi_trait,
    sabi_types::VersionStrings,
    std_types::{RBoxError, RDuration, ROk, ROption, RString, RVec},
};
use anyhow::format_err;
use arci::nalgebra;
use async_ffi::{FfiFuture, FutureExt as _};

pub(crate) use self::impls::*;
use crate::PluginProxy;

type RResult<T, E = RError> = abi_stable::std_types::RResult<T, E>;

// =============================================================================
// std::time::SystemTime

/// FFI-safe equivalent of [`std::time::SystemTime`].
///
/// `SystemTime` does not implement `StableAbi`, so convert it to duration since unix epoch,
/// and recover it on conversion to `SystemTime`.
/// This is inspired by the way `serde` implements `Serialize`/`Deserialize` on `SystemTime`.
///
/// Refs:
/// - <https://github.com/serde-rs/serde/blob/v1.0.126/serde/src/ser/impls.rs#L610-L625>
/// - <https://github.com/serde-rs/serde/blob/v1.0.126/serde/src/de/impls.rs#L1993-L2138>
#[repr(C)]
#[derive(StableAbi)]
pub(crate) struct RSystemTime {
    duration_since_epoch: RDuration,
}

impl TryFrom<SystemTime> for RSystemTime {
    type Error = RError;

    fn try_from(val: SystemTime) -> Result<Self, Self::Error> {
        let duration_since_epoch = val
            .duration_since(SystemTime::UNIX_EPOCH)
            .map_err(|_| format_err!("SystemTime must be later than UNIX_EPOCH"))?;
        Ok(Self {
            duration_since_epoch: duration_since_epoch.into(),
        })
    }
}

impl TryFrom<RSystemTime> for SystemTime {
    type Error = RError;

    fn try_from(val: RSystemTime) -> Result<Self, Self::Error> {
        let duration_since_epoch = val.duration_since_epoch.into();
        SystemTime::UNIX_EPOCH
            .checked_add(duration_since_epoch)
            .ok_or_else(|| format_err!("overflow deserializing SystemTime").into())
    }
}

// =============================================================================
// nalgebra::Isometry2<f64>

/// FFI-safe equivalent of [`nalgebra::Isometry2<f64>`](nalgebra::Isometry2).
#[repr(C)]
#[derive(StableAbi)]
pub(crate) struct RIsometry2F64 {
    rotation: RUnitComplexF64,
    translation: RTranslation2F64,
}

impl From<nalgebra::Isometry2<f64>> for RIsometry2F64 {
    fn from(val: nalgebra::Isometry2<f64>) -> Self {
        Self {
            rotation: val.rotation.into(),
            translation: val.translation.into(),
        }
    }
}

impl From<RIsometry2F64> for nalgebra::Isometry2<f64> {
    fn from(val: RIsometry2F64) -> Self {
        Self::from_parts(val.translation.into(), val.rotation.into())
    }
}

/// FFI-safe equivalent of [`nalgebra::UnitComplex<f64>`](nalgebra::UnitComplex).
#[repr(C)]
#[derive(StableAbi)]
struct RUnitComplexF64 {
    re: f64,
    im: f64,
}

impl From<nalgebra::UnitComplex<f64>> for RUnitComplexF64 {
    fn from(val: nalgebra::UnitComplex<f64>) -> Self {
        let val = val.into_inner();
        Self {
            re: val.re,
            im: val.im,
        }
    }
}

impl From<RUnitComplexF64> for nalgebra::UnitComplex<f64> {
    fn from(val: RUnitComplexF64) -> Self {
        Self::from_complex(nalgebra::Complex {
            re: val.re,
            im: val.im,
        })
    }
}

/// FFI-safe equivalent of [`nalgebra::Translation2<f64>`](nalgebra::Translation2).
#[repr(C)]
#[derive(StableAbi)]
struct RTranslation2F64 {
    x: f64,
    y: f64,
}

impl From<nalgebra::Translation2<f64>> for RTranslation2F64 {
    fn from(val: nalgebra::Translation2<f64>) -> Self {
        Self {
            x: val.vector.x,
            y: val.vector.y,
        }
    }
}

impl From<RTranslation2F64> for nalgebra::Translation2<f64> {
    fn from(val: RTranslation2F64) -> Self {
        Self::new(val.x, val.y)
    }
}

// =============================================================================
// nalgebra::Isometry3<f64>

/// FFI-safe equivalent of [`nalgebra::Isometry3<f64>`](nalgebra::Isometry3).
#[repr(C)]
#[derive(StableAbi)]
pub(crate) struct RIsometry3F64 {
    rotation: RUnitQuaternionF64,
    translation: RTranslation3F64,
}

impl From<nalgebra::Isometry3<f64>> for RIsometry3F64 {
    fn from(val: nalgebra::Isometry3<f64>) -> Self {
        Self {
            rotation: val.rotation.into(),
            translation: val.translation.into(),
        }
    }
}

impl From<RIsometry3F64> for nalgebra::Isometry3<f64> {
    fn from(val: RIsometry3F64) -> Self {
        Self::from_parts(val.translation.into(), val.rotation.into())
    }
}

/// FFI-safe equivalent of [`nalgebra::UnitQuaternion<f64>`](nalgebra::UnitQuaternion).
#[repr(C)]
#[derive(StableAbi)]
struct RUnitQuaternionF64 {
    x: f64,
    y: f64,
    z: f64,
    w: f64,
}

impl From<nalgebra::UnitQuaternion<f64>> for RUnitQuaternionF64 {
    fn from(val: nalgebra::UnitQuaternion<f64>) -> Self {
        let val = val.into_inner();
        Self {
            x: val.coords.x,
            y: val.coords.y,
            z: val.coords.z,
            w: val.coords.w,
        }
    }
}

impl From<RUnitQuaternionF64> for nalgebra::UnitQuaternion<f64> {
    fn from(val: RUnitQuaternionF64) -> Self {
        Self::from_quaternion(nalgebra::Quaternion::new(val.w, val.x, val.y, val.z))
    }
}

/// FFI-safe equivalent of [`nalgebra::Translation3<f64>`](nalgebra::Translation3).
#[repr(C)]
#[derive(StableAbi)]
struct RTranslation3F64 {
    x: f64,
    y: f64,
    z: f64,
}

impl From<nalgebra::Translation3<f64>> for RTranslation3F64 {
    fn from(val: nalgebra::Translation3<f64>) -> Self {
        Self {
            x: val.vector.x,
            y: val.vector.y,
            z: val.vector.z,
        }
    }
}

impl From<RTranslation3F64> for nalgebra::Translation3<f64> {
    fn from(val: RTranslation3F64) -> Self {
        Self::new(val.x, val.y, val.z)
    }
}

// =============================================================================
// arci::Error

/// FFI-safe equivalent of [`arci::Error`].
#[repr(C)]
#[derive(StableAbi)]
pub(crate) struct RError {
    repr: RBoxError,
}

impl From<arci::Error> for RError {
    fn from(e: arci::Error) -> Self {
        Self {
            // TODO: propagate error kind.
            repr: RBoxError::from_box(e.into()),
        }
    }
}

impl From<anyhow::Error> for RError {
    fn from(e: anyhow::Error) -> Self {
        Self {
            // TODO: propagate error kind.
            repr: RBoxError::from_box(e.into()),
        }
    }
}

impl From<RError> for arci::Error {
    fn from(e: RError) -> Self {
        // TODO: propagate error kind.
        Self::Other(format_err!("{}", e.repr))
    }
}

// =============================================================================
// arci::WaitFuture

#[repr(C)]
#[derive(StableAbi)]
#[must_use]
pub(crate) struct RWaitFuture(FfiFuture<RResult<()>>);

impl From<arci::WaitFuture> for RWaitFuture {
    #[allow(clippy::unit_arg)] // false positive that triggered for external macro
    fn from(wait: arci::WaitFuture) -> Self {
        Self(async move { ROk(rtry!(wait.await)) }.into_ffi())
    }
}

impl From<RWaitFuture> for arci::WaitFuture {
    fn from(wait: RWaitFuture) -> Self {
        arci::WaitFuture::new(async move { Ok(wait.0.await.into_result()?) })
    }
}

// =============================================================================
// PluginMod

// Not public API.
#[doc(hidden)]
#[allow(missing_debug_implementations)]
#[repr(C)]
#[derive(StableAbi)]
#[sabi(kind(Prefix))]
#[sabi(missing_field(panic))]
pub struct PluginMod {
    #[sabi(last_prefix_field)]
    pub(crate) plugin_constructor: extern "C" fn() -> PluginProxy,
}

impl RootModule for PluginMod_Ref {
    const BASE_NAME: &'static str = "plugin";
    const NAME: &'static str = "plugin";
    const VERSION_STRINGS: VersionStrings = package_version_strings!();

    declare_root_module_statics!(PluginMod_Ref);
}

impl PluginMod_Ref {
    #[doc(hidden)]
    pub fn new(plugin_constructor: extern "C" fn() -> PluginProxy) -> Self {
        PluginMod { plugin_constructor }.leak_into_prefix()
    }
}
