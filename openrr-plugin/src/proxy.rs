//! This module defines FFI-safe equivalents of the various types and traits
//! used in arci and openrr-plugin. The types defined by this module will never
//! appear in the public API, and the conversion is done internally.

#![allow(clippy::let_unit_value)] // this lint is triggered for code generated by #[sabi_trait]
#![allow(clippy::unnecessary_cast)] // this lint is triggered for code generated by #[sabi_trait]

#[rustfmt::skip]
#[path = "gen/proxy.rs"]
mod impls;

use std::{future::Future, sync::Arc, time::SystemTime};

use abi_stable::{
    declare_root_module_statics,
    erased_types::TD_Opaque,
    library::RootModule,
    package_version_strings,
    prefix_type::PrefixTypeTrait,
    rtry, sabi_trait,
    sabi_types::VersionStrings,
    std_types::{RBox, RBoxError, RDuration, ROk, ROption, RString, RVec},
    StableAbi,
};
use anyhow::format_err;
use arci::nalgebra;

pub(crate) use self::impls::*;
use crate::PluginProxy;

type RResult<T, E = RError> = abi_stable::std_types::RResult<T, E>;

fn block_in_place<T>(f: impl Future<Output = T>) -> T {
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap()
        .block_on(f)
}

// =============================================================================
// std::time::SystemTime

/// FFI-safe equivalent of [`std::time::SystemTime`].
///
/// `SystemTime` does not implement `StableAbi`, so convert it to duration since unix epoch,
/// and recover it on conversion to `SystemTime`.
/// This is inspired by the way `serde` implements `Serialize`/`Deserialize` on `SystemTime`.
///
/// Refs:
/// - <https://github.com/serde-rs/serde/blob/v1.0.126/serde/src/ser/impls.rs#L610-L625>
/// - <https://github.com/serde-rs/serde/blob/v1.0.126/serde/src/de/impls.rs#L1993-L2138>
#[repr(C)]
#[derive(StableAbi)]
pub(crate) struct RSystemTime {
    duration_since_epoch: RDuration,
}

impl TryFrom<SystemTime> for RSystemTime {
    type Error = RError;

    fn try_from(val: SystemTime) -> Result<Self, Self::Error> {
        let duration_since_epoch = val
            .duration_since(SystemTime::UNIX_EPOCH)
            .map_err(|_| format_err!("SystemTime must be later than UNIX_EPOCH"))?;
        Ok(Self {
            duration_since_epoch: duration_since_epoch.into(),
        })
    }
}

impl TryFrom<RSystemTime> for SystemTime {
    type Error = RError;

    fn try_from(val: RSystemTime) -> Result<Self, Self::Error> {
        let duration_since_epoch = val.duration_since_epoch.into();
        SystemTime::UNIX_EPOCH
            .checked_add(duration_since_epoch)
            .ok_or_else(|| format_err!("overflow deserializing SystemTime").into())
    }
}

// =============================================================================
// nalgebra::Isometry2<f64>

/// FFI-safe equivalent of [`nalgebra::Isometry2<f64>`](nalgebra::Isometry2).
#[repr(C)]
#[derive(StableAbi)]
pub(crate) struct RIsometry2F64 {
    rotation: RUnitComplexF64,
    translation: RTranslation2F64,
}

impl From<nalgebra::Isometry2<f64>> for RIsometry2F64 {
    fn from(val: nalgebra::Isometry2<f64>) -> Self {
        Self {
            rotation: val.rotation.into(),
            translation: val.translation.into(),
        }
    }
}

impl From<RIsometry2F64> for nalgebra::Isometry2<f64> {
    fn from(val: RIsometry2F64) -> Self {
        Self::from_parts(val.translation.into(), val.rotation.into())
    }
}

/// FFI-safe equivalent of [`nalgebra::UnitComplex<f64>`](nalgebra::UnitComplex).
#[repr(C)]
#[derive(StableAbi)]
struct RUnitComplexF64 {
    re: f64,
    im: f64,
}

impl From<nalgebra::UnitComplex<f64>> for RUnitComplexF64 {
    fn from(val: nalgebra::UnitComplex<f64>) -> Self {
        let val = val.into_inner();
        Self {
            re: val.re,
            im: val.im,
        }
    }
}

impl From<RUnitComplexF64> for nalgebra::UnitComplex<f64> {
    fn from(val: RUnitComplexF64) -> Self {
        Self::from_complex(nalgebra::Complex {
            re: val.re,
            im: val.im,
        })
    }
}

/// FFI-safe equivalent of [`nalgebra::Translation2<f64>`](nalgebra::Translation2).
#[repr(C)]
#[derive(StableAbi)]
struct RTranslation2F64 {
    x: f64,
    y: f64,
}

impl From<nalgebra::Translation2<f64>> for RTranslation2F64 {
    fn from(val: nalgebra::Translation2<f64>) -> Self {
        Self {
            x: val.vector.x,
            y: val.vector.y,
        }
    }
}

impl From<RTranslation2F64> for nalgebra::Translation2<f64> {
    fn from(val: RTranslation2F64) -> Self {
        Self::new(val.x, val.y)
    }
}

// =============================================================================
// nalgebra::Isometry3<f64>

/// FFI-safe equivalent of [`nalgebra::Isometry3<f64>`](nalgebra::Isometry3).
#[repr(C)]
#[derive(StableAbi)]
pub(crate) struct RIsometry3F64 {
    rotation: RUnitQuaternionF64,
    translation: RTranslation3F64,
}

impl From<nalgebra::Isometry3<f64>> for RIsometry3F64 {
    fn from(val: nalgebra::Isometry3<f64>) -> Self {
        Self {
            rotation: val.rotation.into(),
            translation: val.translation.into(),
        }
    }
}

impl From<RIsometry3F64> for nalgebra::Isometry3<f64> {
    fn from(val: RIsometry3F64) -> Self {
        Self::from_parts(val.translation.into(), val.rotation.into())
    }
}

/// FFI-safe equivalent of [`nalgebra::UnitQuaternion<f64>`](nalgebra::UnitQuaternion).
#[repr(C)]
#[derive(StableAbi)]
struct RUnitQuaternionF64 {
    x: f64,
    y: f64,
    z: f64,
    w: f64,
}

impl From<nalgebra::UnitQuaternion<f64>> for RUnitQuaternionF64 {
    fn from(val: nalgebra::UnitQuaternion<f64>) -> Self {
        let val = val.into_inner();
        Self {
            x: val.coords.x,
            y: val.coords.y,
            z: val.coords.z,
            w: val.coords.w,
        }
    }
}

impl From<RUnitQuaternionF64> for nalgebra::UnitQuaternion<f64> {
    fn from(val: RUnitQuaternionF64) -> Self {
        Self::from_quaternion(nalgebra::Quaternion::new(val.w, val.x, val.y, val.z))
    }
}

/// FFI-safe equivalent of [`nalgebra::Translation3<f64>`](nalgebra::Translation3).
#[repr(C)]
#[derive(StableAbi)]
struct RTranslation3F64 {
    x: f64,
    y: f64,
    z: f64,
}

impl From<nalgebra::Translation3<f64>> for RTranslation3F64 {
    fn from(val: nalgebra::Translation3<f64>) -> Self {
        Self {
            x: val.vector.x,
            y: val.vector.y,
            z: val.vector.z,
        }
    }
}

impl From<RTranslation3F64> for nalgebra::Translation3<f64> {
    fn from(val: RTranslation3F64) -> Self {
        Self::new(val.x, val.y, val.z)
    }
}

// =============================================================================
// arci::Error

/// FFI-safe equivalent of [`arci::Error`].
#[repr(C)]
#[derive(StableAbi)]
pub(crate) struct RError {
    repr: RBoxError,
}

impl From<arci::Error> for RError {
    fn from(e: arci::Error) -> Self {
        Self {
            // TODO: propagate error kind.
            repr: RBoxError::from_box(e.into()),
        }
    }
}

impl From<anyhow::Error> for RError {
    fn from(e: anyhow::Error) -> Self {
        Self {
            // TODO: propagate error kind.
            repr: RBoxError::from_box(e.into()),
        }
    }
}

impl From<RError> for arci::Error {
    fn from(e: RError) -> Self {
        // TODO: propagate error kind.
        Self::Other(format_err!("{}", e.repr))
    }
}

// =============================================================================
// arci::WaitFuture

#[repr(C)]
#[derive(StableAbi)]
#[must_use]
pub(crate) struct RBlockingWait(RBoxWait);

impl RBlockingWait {
    fn from_fn(f: impl FnOnce() -> RResult<()> + Send + 'static) -> Self {
        Self(RBoxWait::from_value(f, TD_Opaque))
    }
}

impl From<arci::WaitFuture> for RBlockingWait {
    fn from(wait: arci::WaitFuture) -> Self {
        Self::from_fn(move || block_in_place(wait).map_err(RError::from).into())
    }
}

impl From<RBlockingWait> for arci::WaitFuture {
    fn from(wait: RBlockingWait) -> Self {
        // Creates a WaitFuture that waits until Wait::wait done only if the future
        // is polled. This future is a bit tricky, but it's more efficient than
        // using only `tokio::task::spawn_blocking` because it doesn't spawn a thread
        // if the WaitFuture is ignored.
        arci::WaitFuture::new(async move {
            tokio::task::spawn_blocking(move || wait.0.wait())
                .await
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_result()?;
            Ok(())
        })
    }
}

type RBoxWait = RWaitTrait_TO<RBox<()>>;

#[sabi_trait]
trait RWaitTrait: Send + 'static {
    fn wait(self) -> RResult<()>;
}

impl<F> RWaitTrait for F
where
    F: FnOnce() -> RResult<()> + Send + 'static,
{
    fn wait(self) -> RResult<()> {
        self()
    }
}

// =============================================================================
// arci::JointTrajectoryClient

/// FFI-safe equivalent of [`Box<dyn arci::JointTrajectoryClient>`](arci::JointTrajectoryClient).
pub(crate) type JointTrajectoryClientTraitObject = RJointTrajectoryClientTrait_TO<RBox<()>>;

#[sabi_trait]
pub(crate) trait RJointTrajectoryClientTrait: Send + Sync + 'static {
    fn joint_names(&self) -> RVec<RString>;
    fn current_joint_positions(&self) -> RResult<RVec<f64>>;
    fn send_joint_positions(
        &self,
        positions: RVec<f64>,
        duration: RDuration,
    ) -> RResult<RBlockingWait>;
    fn send_joint_trajectory(&self, trajectory: RVec<RTrajectoryPoint>) -> RResult<RBlockingWait>;
}

impl<T> RJointTrajectoryClientTrait for T
where
    T: ?Sized + arci::JointTrajectoryClient + 'static,
{
    fn joint_names(&self) -> RVec<RString> {
        arci::JointTrajectoryClient::joint_names(self)
            .into_iter()
            .map(|s| s.into())
            .collect()
    }

    fn current_joint_positions(&self) -> RResult<RVec<f64>> {
        ROk(
            rtry!(arci::JointTrajectoryClient::current_joint_positions(self))
                .into_iter()
                .collect(),
        )
    }

    fn send_joint_positions(
        &self,
        positions: RVec<f64>,
        duration: RDuration,
    ) -> RResult<RBlockingWait> {
        ROk(rtry!(arci::JointTrajectoryClient::send_joint_positions(
            self,
            positions.into_iter().map(f64::from).collect(),
            duration.into(),
        ))
        .into())
    }

    fn send_joint_trajectory(&self, trajectory: RVec<RTrajectoryPoint>) -> RResult<RBlockingWait> {
        ROk(rtry!(arci::JointTrajectoryClient::send_joint_trajectory(
            self,
            trajectory
                .into_iter()
                .map(arci::TrajectoryPoint::from)
                .collect(),
        ))
        .into())
    }
}

// =============================================================================
// arci::Gamepad

/// FFI-safe equivalent of [`Arc<dyn arci::Gamepad>`](arci::Gamepad).
pub(crate) type GamepadTraitObject = RGamepadTrait_TO<RBox<()>>;

#[sabi_trait]
pub(crate) trait RGamepadTrait: Send + Sync + Clone + 'static {
    fn next_event(&self) -> RGamepadEvent;
    fn stop(&self);
}

impl<T> RGamepadTrait for Arc<T>
where
    T: ?Sized + arci::Gamepad + 'static,
{
    fn next_event(&self) -> RGamepadEvent {
        block_in_place(arci::Gamepad::next_event(&**self)).into()
    }

    fn stop(&self) {
        arci::Gamepad::stop(&**self);
    }
}

// =============================================================================
// PluginMod

// Not public API.
#[doc(hidden)]
#[allow(missing_debug_implementations)]
#[repr(C)]
#[derive(StableAbi)]
#[sabi(kind(Prefix))]
#[sabi(missing_field(panic))]
pub struct PluginMod {
    #[sabi(last_prefix_field)]
    pub(crate) plugin_constructor: extern "C" fn() -> PluginProxy,
}

impl RootModule for PluginMod_Ref {
    const BASE_NAME: &'static str = "plugin";
    const NAME: &'static str = "plugin";
    const VERSION_STRINGS: VersionStrings = package_version_strings!();

    declare_root_module_statics!(PluginMod_Ref);
}

impl PluginMod_Ref {
    #[doc(hidden)]
    pub fn new(plugin_constructor: extern "C" fn() -> PluginProxy) -> Self {
        PluginMod { plugin_constructor }.leak_into_prefix()
    }
}
