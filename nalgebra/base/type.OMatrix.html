<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An owned matrix column-major matrix with `R` rows and `C` columns."><title>OMatrix in nalgebra::base - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="nalgebra" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="icon" href="https://nalgebra.org/img/favicon.ico"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../nalgebra/index.html">nalgebra</a><span class="version">0.30.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">OMatrix</a></h2><h3><a href="#aliased-type">Aliased Type</a></h3><h3><a href="#fields">Fields</a></h3><ul class="block field"><li><a href="#structfield.data" title="data">data</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.exp" title="exp">exp</a></li><li><a href="#method.from_column_slice" title="from_column_slice">from_column_slice</a></li><li><a href="#method.from_column_slice-1" title="from_column_slice">from_column_slice</a></li><li><a href="#method.from_column_slice-2" title="from_column_slice">from_column_slice</a></li><li><a href="#method.from_column_slice-3" title="from_column_slice">from_column_slice</a></li><li><a href="#method.from_column_slice_generic" title="from_column_slice_generic">from_column_slice_generic</a></li><li><a href="#method.from_columns" title="from_columns">from_columns</a></li><li><a href="#method.from_diagonal" title="from_diagonal">from_diagonal</a></li><li><a href="#method.from_diagonal_element" title="from_diagonal_element">from_diagonal_element</a></li><li><a href="#method.from_diagonal_element-1" title="from_diagonal_element">from_diagonal_element</a></li><li><a href="#method.from_diagonal_element-2" title="from_diagonal_element">from_diagonal_element</a></li><li><a href="#method.from_diagonal_element-3" title="from_diagonal_element">from_diagonal_element</a></li><li><a href="#method.from_diagonal_element_generic" title="from_diagonal_element_generic">from_diagonal_element_generic</a></li><li><a href="#method.from_element" title="from_element">from_element</a></li><li><a href="#method.from_element-1" title="from_element">from_element</a></li><li><a href="#method.from_element-2" title="from_element">from_element</a></li><li><a href="#method.from_element-3" title="from_element">from_element</a></li><li><a href="#method.from_element_generic" title="from_element_generic">from_element_generic</a></li><li><a href="#method.from_fn" title="from_fn">from_fn</a></li><li><a href="#method.from_fn-1" title="from_fn">from_fn</a></li><li><a href="#method.from_fn-2" title="from_fn">from_fn</a></li><li><a href="#method.from_fn-3" title="from_fn">from_fn</a></li><li><a href="#method.from_fn_generic" title="from_fn_generic">from_fn_generic</a></li><li><a href="#method.from_iterator" title="from_iterator">from_iterator</a></li><li><a href="#method.from_iterator-1" title="from_iterator">from_iterator</a></li><li><a href="#method.from_iterator-2" title="from_iterator">from_iterator</a></li><li><a href="#method.from_iterator-3" title="from_iterator">from_iterator</a></li><li><a href="#method.from_iterator_generic" title="from_iterator_generic">from_iterator_generic</a></li><li><a href="#method.from_partial_diagonal" title="from_partial_diagonal">from_partial_diagonal</a></li><li><a href="#method.from_partial_diagonal-1" title="from_partial_diagonal">from_partial_diagonal</a></li><li><a href="#method.from_partial_diagonal-2" title="from_partial_diagonal">from_partial_diagonal</a></li><li><a href="#method.from_partial_diagonal-3" title="from_partial_diagonal">from_partial_diagonal</a></li><li><a href="#method.from_partial_diagonal_generic" title="from_partial_diagonal_generic">from_partial_diagonal_generic</a></li><li><a href="#method.from_row_slice" title="from_row_slice">from_row_slice</a></li><li><a href="#method.from_row_slice-1" title="from_row_slice">from_row_slice</a></li><li><a href="#method.from_row_slice-2" title="from_row_slice">from_row_slice</a></li><li><a href="#method.from_row_slice-3" title="from_row_slice">from_row_slice</a></li><li><a href="#method.from_row_slice_generic" title="from_row_slice_generic">from_row_slice_generic</a></li><li><a href="#method.from_rows" title="from_rows">from_rows</a></li><li><a href="#method.from_vec" title="from_vec">from_vec</a></li><li><a href="#method.from_vec-1" title="from_vec">from_vec</a></li><li><a href="#method.from_vec-2" title="from_vec">from_vec</a></li><li><a href="#method.from_vec-3" title="from_vec">from_vec</a></li><li><a href="#method.from_vec_generic" title="from_vec_generic">from_vec_generic</a></li><li><a href="#method.identity" title="identity">identity</a></li><li><a href="#method.identity-1" title="identity">identity</a></li><li><a href="#method.identity-2" title="identity">identity</a></li><li><a href="#method.identity-3" title="identity">identity</a></li><li><a href="#method.identity_generic" title="identity_generic">identity_generic</a></li><li><a href="#method.new_nonuniform_scaling" title="new_nonuniform_scaling">new_nonuniform_scaling</a></li><li><a href="#method.new_scaling" title="new_scaling">new_scaling</a></li><li><a href="#method.new_translation" title="new_translation">new_translation</a></li><li><a href="#method.repeat" title="repeat">repeat</a></li><li><a href="#method.repeat-1" title="repeat">repeat</a></li><li><a href="#method.repeat-2" title="repeat">repeat</a></li><li><a href="#method.repeat-3" title="repeat">repeat</a></li><li><a href="#method.repeat_generic" title="repeat_generic">repeat_generic</a></li><li><a href="#method.resize_horizontally_mut" title="resize_horizontally_mut">resize_horizontally_mut</a></li><li><a href="#method.resize_mut" title="resize_mut">resize_mut</a></li><li><a href="#method.resize_vertically_mut" title="resize_vertically_mut">resize_vertically_mut</a></li><li><a href="#method.zeros" title="zeros">zeros</a></li><li><a href="#method.zeros-1" title="zeros">zeros</a></li><li><a href="#method.zeros-2" title="zeros">zeros</a></li><li><a href="#method.zeros-3" title="zeros">zeros</a></li><li><a href="#method.zeros_generic" title="zeros_generic">zeros_generic</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Bounded-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" title="Bounded">Bounded</a></li><li><a href="#impl-From%3CIsometry%3CT,+R,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" title="From&#60;Isometry&#60;T, R, D&#62;&#62;">From&#60;Isometry&#60;T, R, D&#62;&#62;</a></li><li><a href="#impl-From%3CScale%3CT,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" title="From&#60;Scale&#60;T, D&#62;&#62;">From&#60;Scale&#60;T, D&#62;&#62;</a></li><li><a href="#impl-From%3CSimilarity%3CT,+R,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" title="From&#60;Similarity&#60;T, R, D&#62;&#62;">From&#60;Similarity&#60;T, R, D&#62;&#62;</a></li><li><a href="#impl-From%3CTransform%3CT,+C,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" title="From&#60;Transform&#60;T, C, D&#62;&#62;">From&#60;Transform&#60;T, C, D&#62;&#62;</a></li><li><a href="#impl-From%3CTranslation%3CT,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" title="From&#60;Translation&#60;T, D&#62;&#62;">From&#60;Translation&#60;T, D&#62;&#62;</a></li><li><a href="#impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+2%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" title="From&#60;[Matrix&#60;&#60;T as SimdValue&#62;::Element, R, C, &#60;DefaultAllocator as Allocator&#60;&#60;T as SimdValue&#62;::Element, R, C&#62;&#62;::Buffer&#62;; 2]&#62;">From&#60;[Matrix&#60;&#60;T as SimdValue&#62;::Element, R, C, &#60;DefaultAllocator as Allocator&#60;&#60;T as SimdValue&#62;::Element, R, C&#62;&#62;::Buffer&#62;; 2]&#62;</a></li><li><a href="#impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+4%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" title="From&#60;[Matrix&#60;&#60;T as SimdValue&#62;::Element, R, C, &#60;DefaultAllocator as Allocator&#60;&#60;T as SimdValue&#62;::Element, R, C&#62;&#62;::Buffer&#62;; 4]&#62;">From&#60;[Matrix&#60;&#60;T as SimdValue&#62;::Element, R, C, &#60;DefaultAllocator as Allocator&#60;&#60;T as SimdValue&#62;::Element, R, C&#62;&#62;::Buffer&#62;; 4]&#62;</a></li><li><a href="#impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+8%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" title="From&#60;[Matrix&#60;&#60;T as SimdValue&#62;::Element, R, C, &#60;DefaultAllocator as Allocator&#60;&#60;T as SimdValue&#62;::Element, R, C&#62;&#62;::Buffer&#62;; 8]&#62;">From&#60;[Matrix&#60;&#60;T as SimdValue&#62;::Element, R, C, &#60;DefaultAllocator as Allocator&#60;&#60;T as SimdValue&#62;::Element, R, C&#62;&#62;::Buffer&#62;; 8]&#62;</a></li><li><a href="#impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+16%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" title="From&#60;[Matrix&#60;&#60;T as SimdValue&#62;::Element, R, C, &#60;DefaultAllocator as Allocator&#60;&#60;T as SimdValue&#62;::Element, R, C&#62;&#62;::Buffer&#62;; 16]&#62;">From&#60;[Matrix&#60;&#60;T as SimdValue&#62;::Element, R, C, &#60;DefaultAllocator as Allocator&#60;&#60;T as SimdValue&#62;::Element, R, C&#62;&#62;::Buffer&#62;; 16]&#62;</a></li><li><a href="#impl-Normed-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" title="Normed">Normed</a></li><li><a href="#impl-One-for-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" title="One">One</a></li><li><a href="#impl-Product-for-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" title="Product">Product</a></li><li><a href="#impl-Product%3C%26Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E%3E-for-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" title="Product&#60;&#38;&#39;a Matrix&#60;T, D, D, &#60;DefaultAllocator as Allocator&#60;T, D, D&#62;&#62;::Buffer&#62;&#62;">Product&#60;&#38;&#39;a Matrix&#60;T, D, D, &#60;DefaultAllocator as Allocator&#60;T, D, D&#62;&#62;::Buffer&#62;&#62;</a></li><li><a href="#impl-SimdValue-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" title="SimdValue">SimdValue</a></li><li><a href="#impl-SubsetOf%3CMatrix%3CT2,+R2,+C2,+%3CDefaultAllocator+as+Allocator%3CT2,+R2,+C2%3E%3E::Buffer%3E%3E-for-Matrix%3CT1,+R1,+C1,+%3CDefaultAllocator+as+Allocator%3CT1,+R1,+C1%3E%3E::Buffer%3E" title="SubsetOf&#60;Matrix&#60;T2, R2, C2, &#60;DefaultAllocator as Allocator&#60;T2, R2, C2&#62;&#62;::Buffer&#62;&#62;">SubsetOf&#60;Matrix&#60;T2, R2, C2, &#60;DefaultAllocator as Allocator&#60;T2, R2, C2&#62;&#62;::Buffer&#62;&#62;</a></li><li><a href="#impl-Sum-for-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E" title="Sum">Sum</a></li><li><a href="#impl-Sum-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" title="Sum">Sum</a></li><li><a href="#impl-Sum%3C%26Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E%3E-for-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E" title="Sum&#60;&#38;&#39;a Matrix&#60;T, Dynamic, C, &#60;DefaultAllocator as Allocator&#60;T, Dynamic, C&#62;&#62;::Buffer&#62;&#62;">Sum&#60;&#38;&#39;a Matrix&#60;T, Dynamic, C, &#60;DefaultAllocator as Allocator&#60;T, Dynamic, C&#62;&#62;::Buffer&#62;&#62;</a></li><li><a href="#impl-Sum%3C%26Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" title="Sum&#60;&#38;&#39;a Matrix&#60;T, R, C, &#60;DefaultAllocator as Allocator&#60;T, R, C&#62;&#62;::Buffer&#62;&#62;">Sum&#60;&#38;&#39;a Matrix&#60;T, R, C, &#60;DefaultAllocator as Allocator&#60;T, R, C&#62;&#62;::Buffer&#62;&#62;</a></li><li><a href="#impl-Zero-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" title="Zero">Zero</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In nalgebra::<wbr>base</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">nalgebra</a>::<wbr><a href="index.html">base</a></div><h1>Type Alias <span class="type">OMatrix</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/nalgebra/base/alias.rs.html#22">Source</a> </span></div><pre class="rust item-decl"><code>pub type OMatrix&lt;T, R, C&gt; = <a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;T, R, C, <a class="type" href="storage/type.Owned.html" title="type nalgebra::base::storage::Owned">Owned</a>&lt;T, R, C&gt;&gt;;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An owned matrix column-major matrix with <code>R</code> rows and <code>C</code> columns.</p>
<p><strong>Because this is an alias, not all its methods are listed here. See the <a href="struct.Matrix.html" title="struct nalgebra::base::Matrix"><code>Matrix</code></a> type too.</strong></p>
</div></details><h2 id="aliased-type" class="section-header">Aliased Type<a href="#aliased-type" class="anchor">§</a></h2><pre class="rust item-decl"><code><div class="code-attribute">#[repr(C)]</div>pub struct OMatrix&lt;T, R, C&gt; {
    pub data: &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a>,
    <span class="comment">/* private fields */</span>
}</code></pre><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.data" class="structfield section-header"><a href="#structfield.data" class="anchor field">§</a><code>data: &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a></code></span><div class="docblock"><p>The data storage that contains all the matrix components. Disappointed?</p>
<p>Well, if you came here to see how you can access the matrix components,
you may be in luck: you can access the individual components of all vectors with compile-time
dimensions &lt;= 6 using field notation like this:
<code>vec.x</code>, <code>vec.y</code>, <code>vec.z</code>, <code>vec.w</code>, <code>vec.a</code>, <code>vec.b</code>. Reference and assignation work too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>vec = Vector3::new(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);
vec.x = <span class="number">10.0</span>;
vec.y += <span class="number">30.0</span>;
<span class="macro">assert_eq!</span>(vec.x, <span class="number">10.0</span>);
<span class="macro">assert_eq!</span>(vec.y + <span class="number">100.0</span>, <span class="number">132.0</span>);</code></pre></div>
<p>Similarly, for matrices with compile-time dimensions &lt;= 6, you can use field notation
like this: <code>mat.m11</code>, <code>mat.m42</code>, etc. The first digit identifies the row to address
and the second digit identifies the column to address. So <code>mat.m13</code> identifies the component
at the first row and third column (note that the count of rows and columns start at 1 instead
of 0 here. This is so we match the mathematical notation).</p>
<p>For all matrices and vectors, independently from their size, individual components can
be accessed and modified using indexing: <code>vec[20]</code>, <code>mat[(20, 19)]</code>. Here the indexing
starts at 0 as you would expect.</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/cg.rs.html#25-70">Source</a><a href="#impl-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, D: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, D, D&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, D, D&gt;,</div></h3><div class="docblock"><h4 id="translation-and-scaling-in-any-dimension"><a class="doc-anchor" href="#translation-and-scaling-in-any-dimension">§</a>Translation and scaling in any dimension</h4></div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new_scaling" class="method"><a class="src rightside" href="../../src/nalgebra/base/cg.rs.html#32-37">Source</a><h4 class="code-header">pub fn <a href="#method.new_scaling" class="fn">new_scaling</a>(scaling: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new homogeneous matrix that applies the same scaling factor on each dimension.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_nonuniform_scaling" class="method"><a class="src rightside" href="../../src/nalgebra/base/cg.rs.html#41-52">Source</a><h4 class="code-header">pub fn <a href="#method.new_nonuniform_scaling" class="fn">new_nonuniform_scaling</a>&lt;SB&gt;(
    scaling: &amp;<a class="type" href="type.Vector.html" title="type nalgebra::base::Vector">Vector</a>&lt;T, <a class="type" href="dimension/type.DimNameDiff.html" title="type nalgebra::base::dimension::DimNameDiff">DimNameDiff</a>&lt;D, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, SB&gt;,
) -&gt; Self<div class="where">where
    D: <a class="trait" href="dimension/trait.DimNameSub.html" title="trait nalgebra::base::dimension::DimNameSub">DimNameSub</a>&lt;<a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;,
    SB: <a class="trait" href="storage/trait.Storage.html" title="trait nalgebra::base::storage::Storage">Storage</a>&lt;T, <a class="type" href="dimension/type.DimNameDiff.html" title="type nalgebra::base::dimension::DimNameDiff">DimNameDiff</a>&lt;D, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a new homogeneous matrix that applies a distinct scaling factor for each dimension.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_translation" class="method"><a class="src rightside" href="../../src/nalgebra/base/cg.rs.html#56-69">Source</a><h4 class="code-header">pub fn <a href="#method.new_translation" class="fn">new_translation</a>&lt;SB&gt;(
    translation: &amp;<a class="type" href="type.Vector.html" title="type nalgebra::base::Vector">Vector</a>&lt;T, <a class="type" href="dimension/type.DimNameDiff.html" title="type nalgebra::base::dimension::DimNameDiff">DimNameDiff</a>&lt;D, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, SB&gt;,
) -&gt; Self<div class="where">where
    D: <a class="trait" href="dimension/trait.DimNameSub.html" title="trait nalgebra::base::dimension::DimNameSub">DimNameSub</a>&lt;<a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;,
    SB: <a class="trait" href="storage/trait.Storage.html" title="trait nalgebra::base::storage::Storage">Storage</a>&lt;T, <a class="type" href="dimension/type.DimNameDiff.html" title="type nalgebra::base::dimension::DimNameDiff">DimNameDiff</a>&lt;D, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a new homogeneous matrix that applies a pure translation.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#51-325">Source</a><a href="#impl-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>, R: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>, C: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;,</div></h3><div class="docblock"><h4 id="generic-constructors"><a class="doc-anchor" href="#generic-constructors">§</a>Generic constructors</h4>
<p>This set of matrix and vector construction functions are all generic
with-regard to the matrix dimensions. They all expect to be given
the dimension as inputs.</p>
</div></section></summary><div class="docblock"><p>These functions should only be used when working on dimension-generic code.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_element_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#57-60">Source</a><h4 class="code-header">pub fn <a href="#method.from_element_generic" class="fn">from_element_generic</a>(nrows: R, ncols: C, elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with all its elements set to <code>elem</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#66-69">Source</a><h4 class="code-header">pub fn <a href="#method.repeat_generic" class="fn">repeat_generic</a>(nrows: R, ncols: C, elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with all its elements set to <code>elem</code>.</p>
<p>Same as <code>from_element_generic</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.zeros_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#73-78">Source</a><h4 class="code-header">pub fn <a href="#method.zeros_generic" class="fn">zeros_generic</a>(nrows: R, ncols: C) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a matrix with all its elements set to 0.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_iterator_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#82-87">Source</a><h4 class="code-header">pub fn <a href="#method.from_iterator_generic" class="fn">from_iterator_generic</a>&lt;I&gt;(nrows: R, ncols: C, iter: I) -&gt; Self<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a matrix with all its elements filled by an iterator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_row_slice_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#95-114">Source</a><h4 class="code-header">pub fn <a href="#method.from_row_slice_generic" class="fn">from_row_slice_generic</a>(nrows: R, ncols: C, slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with its elements filled with the components provided by a slice in
row-major order.</p>
<p>The order of elements in the slice must follow the usual mathematic writing, i.e.,
row-by-row.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_column_slice_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#119-121">Source</a><h4 class="code-header">pub fn <a href="#method.from_column_slice_generic" class="fn">from_column_slice_generic</a>(nrows: R, ncols: C, slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with its elements filled with the components provided by a slice. The
components must have the same layout as the matrix data storage (i.e. column-major).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_fn_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#126-142">Source</a><h4 class="code-header">pub fn <a href="#method.from_fn_generic" class="fn">from_fn_generic</a>&lt;F&gt;(nrows: R, ncols: C, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; T,</div></h4></section></summary><div class="docblock"><p>Creates a matrix filled with the results of a function applied to each of its component
coordinates.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.identity_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#149-154">Source</a><h4 class="code-header">pub fn <a href="#method.identity_generic" class="fn">identity_generic</a>(nrows: R, ncols: C) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,</div></h4></section></summary><div class="docblock"><p>Creates a new identity matrix.</p>
<p>If the matrix is not square, the largest square submatrix starting at index <code>(0, 0)</code> is set
to the identity matrix. All other entries are set to zero.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_diagonal_element_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#161-172">Source</a><h4 class="code-header">pub fn <a href="#method.from_diagonal_element_generic" class="fn">from_diagonal_element_generic</a>(nrows: R, ncols: C, elt: T) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,</div></h4></section></summary><div class="docblock"><p>Creates a new matrix with its diagonal filled with copies of <code>elt</code>.</p>
<p>If the matrix is not square, the largest square submatrix starting at index <code>(0, 0)</code> is set
to the identity matrix. All other entries are set to zero.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_partial_diagonal_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#179-194">Source</a><h4 class="code-header">pub fn <a href="#method.from_partial_diagonal_generic" class="fn">from_partial_diagonal_generic</a>(nrows: R, ncols: C, elts: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a new matrix that may be rectangular. The first <code>elts.len()</code> diagonal elements are
filled with the content of <code>elts</code>. Others are set to 0.</p>
<p>Panics if <code>elts.len()</code> is larger than the minimum among <code>nrows</code> and <code>ncols</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_rows" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#213-236">Source</a><h4 class="code-header">pub fn <a href="#method.from_rows" class="fn">from_rows</a>&lt;SB&gt;(rows: &amp;[<a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;T, <a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;1&gt;, C, SB&gt;]) -&gt; Self<div class="where">where
    SB: <a class="trait" href="storage/trait.RawStorage.html" title="trait nalgebra::base::storage::RawStorage">RawStorage</a>&lt;T, <a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;1&gt;, C&gt;,</div></h4></section></summary><div class="docblock"><p>Builds a new matrix from its rows.</p>
<p>Panics if not enough rows are provided (for statically-sized matrices), or if all rows do
not have the same dimensions.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix3::from_rows(<span class="kw-2">&amp;</span>[ RowVector3::new(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>),  RowVector3::new(<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>),  RowVector3::new(<span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>) ]);

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">2.0 </span>&amp;&amp; m.m13 == <span class="number">3.0 </span>&amp;&amp;
        m.m21 == <span class="number">4.0 </span>&amp;&amp; m.m22 == <span class="number">5.0 </span>&amp;&amp; m.m23 == <span class="number">6.0 </span>&amp;&amp;
        m.m31 == <span class="number">7.0 </span>&amp;&amp; m.m32 == <span class="number">8.0 </span>&amp;&amp; m.m33 == <span class="number">9.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_columns" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#255-278">Source</a><h4 class="code-header">pub fn <a href="#method.from_columns" class="fn">from_columns</a>&lt;SB&gt;(columns: &amp;[<a class="type" href="type.Vector.html" title="type nalgebra::base::Vector">Vector</a>&lt;T, R, SB&gt;]) -&gt; Self<div class="where">where
    SB: <a class="trait" href="storage/trait.RawStorage.html" title="trait nalgebra::base::storage::RawStorage">RawStorage</a>&lt;T, R&gt;,</div></h4></section></summary><div class="docblock"><p>Builds a new matrix from its columns.</p>
<p>Panics if not enough columns are provided (for statically-sized matrices), or if all
columns do not have the same dimensions.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix3::from_columns(<span class="kw-2">&amp;</span>[ Vector3::new(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>),  Vector3::new(<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>),  Vector3::new(<span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>) ]);

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">4.0 </span>&amp;&amp; m.m13 == <span class="number">7.0 </span>&amp;&amp;
        m.m21 == <span class="number">2.0 </span>&amp;&amp; m.m22 == <span class="number">5.0 </span>&amp;&amp; m.m23 == <span class="number">8.0 </span>&amp;&amp;
        m.m31 == <span class="number">3.0 </span>&amp;&amp; m.m32 == <span class="number">6.0 </span>&amp;&amp; m.m33 == <span class="number">9.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_vec_generic" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#322-324">Source</a><h4 class="code-header">pub fn <a href="#method.from_vec_generic" class="fn">from_vec_generic</a>(nrows: R, ncols: C, data: <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix backed by a given <code>Vec</code>.</p>
<p>The output matrix is filled column-by-column.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>vec = <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span>vec_ptr = vec.as_ptr();

<span class="kw">let </span>matrix = Matrix::from_vec_generic(Dynamic::new(vec.len()), Const::&lt;<span class="number">1</span>&gt;, vec);
<span class="kw">let </span>matrix_storage_ptr = matrix.data.as_vec().as_ptr();

<span class="comment">// `matrix` is backed by exactly the same `Vec` as it was constructed from.
</span><span class="macro">assert_eq!</span>(matrix_storage_ptr, vec_ptr);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E-1" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#327-366">Source</a><a href="#impl-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T, D: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, D, D&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, D, D&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_diagonal" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#351-365">Source</a><h4 class="code-header">pub fn <a href="#method.from_diagonal" class="fn">from_diagonal</a>&lt;SB: <a class="trait" href="storage/trait.RawStorage.html" title="trait nalgebra::base::storage::RawStorage">RawStorage</a>&lt;T, D&gt;&gt;(diag: &amp;<a class="type" href="type.Vector.html" title="type nalgebra::base::Vector">Vector</a>&lt;T, D, SB&gt;) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a square matrix with its diagonal set to <code>diag</code> and all other entries set to 0.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix3::from_diagonal(<span class="kw-2">&amp;</span>Vector3::new(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>));
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_diagonal(<span class="kw-2">&amp;</span>DVector::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]));

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">0.0 </span>&amp;&amp;
        m.m31 == <span class="number">0.0 </span>&amp;&amp; m.m32 == <span class="number">0.0 </span>&amp;&amp; m.m33 == <span class="number">3.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">2</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">2</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">2</span>, <span class="number">2</span>)] == <span class="number">3.0</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E-1" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#606-615">Source</a><a href="#impl-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>, R: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>, C: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;,</div></h3><div class="docblock"><h4 id="constructors-of-statically-sized-vectors-or-statically-sized-matrices"><a class="doc-anchor" href="#constructors-of-statically-sized-vectors-or-statically-sized-matrices">§</a>Constructors of statically-sized vectors or statically-sized matrices</h4></div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_element" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#611-614">Source</a><h4 class="code-header">pub fn <a href="#method.from_element" class="fn">from_element</a>(elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>elem</code>.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_element(<span class="number">2.0</span>);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_element(<span class="number">3</span>, <span class="number">2.0</span>);
<span class="kw">let </span>m = Matrix2x3::from_element(<span class="number">2.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_element(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2.0</span>);

<span class="macro">assert!</span>(v.x == <span class="number">2.0 </span>&amp;&amp; v.y == <span class="number">2.0 </span>&amp;&amp; v.z == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">2.0 </span>&amp;&amp; m.m12 == <span class="number">2.0 </span>&amp;&amp; m.m13 == <span class="number">2.0 </span>&amp;&amp;
        m.m21 == <span class="number">2.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">2.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#611-614">Source</a><h4 class="code-header">pub fn <a href="#method.repeat" class="fn">repeat</a>(elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>elem</code>.</p>
<p>Same as <code>.from_element</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::repeat(<span class="number">2.0</span>);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::repeat(<span class="number">3</span>, <span class="number">2.0</span>);
<span class="kw">let </span>m = Matrix2x3::repeat(<span class="number">2.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::repeat(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2.0</span>);

<span class="macro">assert!</span>(v.x == <span class="number">2.0 </span>&amp;&amp; v.y == <span class="number">2.0 </span>&amp;&amp; v.z == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">2.0 </span>&amp;&amp; m.m12 == <span class="number">2.0 </span>&amp;&amp; m.m13 == <span class="number">2.0 </span>&amp;&amp;
        m.m21 == <span class="number">2.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">2.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.zeros" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#611-614">Source</a><h4 class="code-header">pub fn <a href="#method.zeros" class="fn">zeros</a>() -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>0</code>.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::&lt;f32&gt;::zeros();
<span class="comment">// The argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::&lt;f32&gt;::zeros(<span class="number">3</span>);
<span class="kw">let </span>m = Matrix2x3::&lt;f32&gt;::zeros();
<span class="comment">// The two arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::&lt;f32&gt;::zeros(<span class="number">2</span>, <span class="number">3</span>);

<span class="macro">assert!</span>(v.x == <span class="number">0.0 </span>&amp;&amp; v.y == <span class="number">0.0 </span>&amp;&amp; v.z == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">0.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">0.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">0.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_iterator" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#611-614">Source</a><h4 class="code-header">pub fn <a href="#method.from_iterator" class="fn">from_iterator</a>&lt;I&gt;(iter: I) -&gt; Self<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements filled by an iterator.</p>
<p>The output matrix is filled column-by-column.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_iterator((<span class="number">0</span>..<span class="number">3</span>).into_iter());
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_iterator(<span class="number">3</span>, (<span class="number">0</span>..<span class="number">3</span>).into_iter());
<span class="kw">let </span>m = Matrix2x3::from_iterator((<span class="number">0</span>..<span class="number">6</span>).into_iter());
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_iterator(<span class="number">2</span>, <span class="number">3</span>, (<span class="number">0</span>..<span class="number">6</span>).into_iter());

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_fn" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#611-614">Source</a><h4 class="code-header">pub fn <a href="#method.from_fn" class="fn">from_fn</a>&lt;F&gt;(f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; T,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector filled with the results of a function applied to each of its
component coordinates.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_fn(|i, <span class="kw">_</span>| i);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_fn(<span class="number">3</span>, |i, <span class="kw">_</span>| i);
<span class="kw">let </span>m = Matrix2x3::from_fn(|i, j| i * <span class="number">3 </span>+ j);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_fn(<span class="number">2</span>, <span class="number">3</span>, |i, j| i * <span class="number">3 </span>+ j);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">1 </span>&amp;&amp; m.m13 == <span class="number">2 </span>&amp;&amp;
        m.m21 == <span class="number">3 </span>&amp;&amp; m.m22 == <span class="number">4 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">4 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.identity" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#611-614">Source</a><h4 class="code-header">pub fn <a href="#method.identity" class="fn">identity</a>() -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,</div></h4></section></summary><div class="docblock"><p>Creates an identity matrix. If the matrix is not square, the largest square
submatrix (starting at the first row and column) is set to the identity while all
other entries are set to zero.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::&lt;f32&gt;::identity();
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::&lt;f32&gt;::identity(<span class="number">2</span>, <span class="number">3</span>);

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">1.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_diagonal_element" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#611-614">Source</a><h4 class="code-header">pub fn <a href="#method.from_diagonal_element" class="fn">from_diagonal_element</a>(elt: T) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,</div></h4></section></summary><div class="docblock"><p>Creates a matrix filled with its diagonal filled with <code>elt</code> and all other
components set to zero.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::from_diagonal_element(<span class="number">5.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_diagonal_element(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5.0</span>);

<span class="macro">assert!</span>(m.m11 == <span class="number">5.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">5.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">5.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">5.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_partial_diagonal" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#611-614">Source</a><h4 class="code-header">pub fn <a href="#method.from_partial_diagonal" class="fn">from_partial_diagonal</a>(elts: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a new matrix that may be rectangular. The first <code>elts.len()</code> diagonal
elements are filled with the content of <code>elts</code>. Others are set to 0.</p>
<p>Panics if <code>elts.len()</code> is larger than the minimum among <code>nrows</code> and <code>ncols</code>.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix3::from_partial_diagonal(<span class="kw-2">&amp;</span>[<span class="number">1.0</span>, <span class="number">2.0</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_partial_diagonal(<span class="number">3</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">1.0</span>, <span class="number">2.0</span>]);

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">0.0 </span>&amp;&amp;
        m.m31 == <span class="number">0.0 </span>&amp;&amp; m.m32 == <span class="number">0.0 </span>&amp;&amp; m.m33 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">2</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">2</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">2</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+R,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+R,+Dynamic%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#618-626">Source</a><a href="#impl-Matrix%3CT,+R,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+R,+Dynamic%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>, R: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;,</div></h3><div class="docblock"><h4 id="constructors-of-matrices-with-a-dynamic-number-of-columns"><a class="doc-anchor" href="#constructors-of-matrices-with-a-dynamic-number-of-columns">§</a>Constructors of matrices with a dynamic number of columns</h4></div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_element-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#622-625">Source</a><h4 class="code-header">pub fn <a href="#method.from_element-1" class="fn">from_element</a>(ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>elem</code>.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_element(<span class="number">2.0</span>);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_element(<span class="number">3</span>, <span class="number">2.0</span>);
<span class="kw">let </span>m = Matrix2x3::from_element(<span class="number">2.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_element(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2.0</span>);

<span class="macro">assert!</span>(v.x == <span class="number">2.0 </span>&amp;&amp; v.y == <span class="number">2.0 </span>&amp;&amp; v.z == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">2.0 </span>&amp;&amp; m.m12 == <span class="number">2.0 </span>&amp;&amp; m.m13 == <span class="number">2.0 </span>&amp;&amp;
        m.m21 == <span class="number">2.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">2.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#622-625">Source</a><h4 class="code-header">pub fn <a href="#method.repeat-1" class="fn">repeat</a>(ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>elem</code>.</p>
<p>Same as <code>.from_element</code>.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::repeat(<span class="number">2.0</span>);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::repeat(<span class="number">3</span>, <span class="number">2.0</span>);
<span class="kw">let </span>m = Matrix2x3::repeat(<span class="number">2.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::repeat(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2.0</span>);

<span class="macro">assert!</span>(v.x == <span class="number">2.0 </span>&amp;&amp; v.y == <span class="number">2.0 </span>&amp;&amp; v.z == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">2.0 </span>&amp;&amp; m.m12 == <span class="number">2.0 </span>&amp;&amp; m.m13 == <span class="number">2.0 </span>&amp;&amp;
        m.m21 == <span class="number">2.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">2.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.zeros-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#622-625">Source</a><h4 class="code-header">pub fn <a href="#method.zeros-1" class="fn">zeros</a>(ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>0</code>.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::&lt;f32&gt;::zeros();
<span class="comment">// The argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::&lt;f32&gt;::zeros(<span class="number">3</span>);
<span class="kw">let </span>m = Matrix2x3::&lt;f32&gt;::zeros();
<span class="comment">// The two arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::&lt;f32&gt;::zeros(<span class="number">2</span>, <span class="number">3</span>);

<span class="macro">assert!</span>(v.x == <span class="number">0.0 </span>&amp;&amp; v.y == <span class="number">0.0 </span>&amp;&amp; v.z == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">0.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">0.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">0.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_iterator-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#622-625">Source</a><h4 class="code-header">pub fn <a href="#method.from_iterator-1" class="fn">from_iterator</a>&lt;I&gt;(ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, iter: I) -&gt; Self<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements filled by an iterator.</p>
<p>The output matrix is filled column-by-column.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_iterator((<span class="number">0</span>..<span class="number">3</span>).into_iter());
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_iterator(<span class="number">3</span>, (<span class="number">0</span>..<span class="number">3</span>).into_iter());
<span class="kw">let </span>m = Matrix2x3::from_iterator((<span class="number">0</span>..<span class="number">6</span>).into_iter());
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_iterator(<span class="number">2</span>, <span class="number">3</span>, (<span class="number">0</span>..<span class="number">6</span>).into_iter());

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_fn-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#622-625">Source</a><h4 class="code-header">pub fn <a href="#method.from_fn-1" class="fn">from_fn</a>&lt;F&gt;(ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; T,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector filled with the results of a function applied to each of its
component coordinates.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_fn(|i, <span class="kw">_</span>| i);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_fn(<span class="number">3</span>, |i, <span class="kw">_</span>| i);
<span class="kw">let </span>m = Matrix2x3::from_fn(|i, j| i * <span class="number">3 </span>+ j);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_fn(<span class="number">2</span>, <span class="number">3</span>, |i, j| i * <span class="number">3 </span>+ j);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">1 </span>&amp;&amp; m.m13 == <span class="number">2 </span>&amp;&amp;
        m.m21 == <span class="number">3 </span>&amp;&amp; m.m22 == <span class="number">4 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">4 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.identity-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#622-625">Source</a><h4 class="code-header">pub fn <a href="#method.identity-1" class="fn">identity</a>(ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,</div></h4></section></summary><div class="docblock"><p>Creates an identity matrix. If the matrix is not square, the largest square
submatrix (starting at the first row and column) is set to the identity while all
other entries are set to zero.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::&lt;f32&gt;::identity();
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::&lt;f32&gt;::identity(<span class="number">2</span>, <span class="number">3</span>);

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">1.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_diagonal_element-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#622-625">Source</a><h4 class="code-header">pub fn <a href="#method.from_diagonal_element-1" class="fn">from_diagonal_element</a>(ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elt: T) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,</div></h4></section></summary><div class="docblock"><p>Creates a matrix filled with its diagonal filled with <code>elt</code> and all other
components set to zero.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::from_diagonal_element(<span class="number">5.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_diagonal_element(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5.0</span>);

<span class="macro">assert!</span>(m.m11 == <span class="number">5.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">5.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">5.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">5.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_partial_diagonal-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#622-625">Source</a><h4 class="code-header">pub fn <a href="#method.from_partial_diagonal-1" class="fn">from_partial_diagonal</a>(ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elts: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a new matrix that may be rectangular. The first <code>elts.len()</code> diagonal
elements are filled with the content of <code>elts</code>. Others are set to 0.</p>
<p>Panics if <code>elts.len()</code> is larger than the minimum among <code>nrows</code> and <code>ncols</code>.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix3::from_partial_diagonal(<span class="kw-2">&amp;</span>[<span class="number">1.0</span>, <span class="number">2.0</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_partial_diagonal(<span class="number">3</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">1.0</span>, <span class="number">2.0</span>]);

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">0.0 </span>&amp;&amp;
        m.m31 == <span class="number">0.0 </span>&amp;&amp; m.m32 == <span class="number">0.0 </span>&amp;&amp; m.m33 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">2</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">2</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">2</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#629-637">Source</a><a href="#impl-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>, C: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;,</div></h3><div class="docblock"><h4 id="constructors-of-dynamic-vectors-and-matrices-with-a-dynamic-number-of-rows"><a class="doc-anchor" href="#constructors-of-dynamic-vectors-and-matrices-with-a-dynamic-number-of-rows">§</a>Constructors of dynamic vectors and matrices with a dynamic number of rows</h4></div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_element-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#633-636">Source</a><h4 class="code-header">pub fn <a href="#method.from_element-2" class="fn">from_element</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>elem</code>.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_element(<span class="number">2.0</span>);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_element(<span class="number">3</span>, <span class="number">2.0</span>);
<span class="kw">let </span>m = Matrix2x3::from_element(<span class="number">2.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_element(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2.0</span>);

<span class="macro">assert!</span>(v.x == <span class="number">2.0 </span>&amp;&amp; v.y == <span class="number">2.0 </span>&amp;&amp; v.z == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">2.0 </span>&amp;&amp; m.m12 == <span class="number">2.0 </span>&amp;&amp; m.m13 == <span class="number">2.0 </span>&amp;&amp;
        m.m21 == <span class="number">2.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">2.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#633-636">Source</a><h4 class="code-header">pub fn <a href="#method.repeat-2" class="fn">repeat</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>elem</code>.</p>
<p>Same as <code>.from_element</code>.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::repeat(<span class="number">2.0</span>);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::repeat(<span class="number">3</span>, <span class="number">2.0</span>);
<span class="kw">let </span>m = Matrix2x3::repeat(<span class="number">2.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::repeat(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2.0</span>);

<span class="macro">assert!</span>(v.x == <span class="number">2.0 </span>&amp;&amp; v.y == <span class="number">2.0 </span>&amp;&amp; v.z == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">2.0 </span>&amp;&amp; m.m12 == <span class="number">2.0 </span>&amp;&amp; m.m13 == <span class="number">2.0 </span>&amp;&amp;
        m.m21 == <span class="number">2.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">2.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.zeros-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#633-636">Source</a><h4 class="code-header">pub fn <a href="#method.zeros-2" class="fn">zeros</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>0</code>.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::&lt;f32&gt;::zeros();
<span class="comment">// The argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::&lt;f32&gt;::zeros(<span class="number">3</span>);
<span class="kw">let </span>m = Matrix2x3::&lt;f32&gt;::zeros();
<span class="comment">// The two arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::&lt;f32&gt;::zeros(<span class="number">2</span>, <span class="number">3</span>);

<span class="macro">assert!</span>(v.x == <span class="number">0.0 </span>&amp;&amp; v.y == <span class="number">0.0 </span>&amp;&amp; v.z == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">0.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">0.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">0.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_iterator-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#633-636">Source</a><h4 class="code-header">pub fn <a href="#method.from_iterator-2" class="fn">from_iterator</a>&lt;I&gt;(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, iter: I) -&gt; Self<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements filled by an iterator.</p>
<p>The output matrix is filled column-by-column.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_iterator((<span class="number">0</span>..<span class="number">3</span>).into_iter());
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_iterator(<span class="number">3</span>, (<span class="number">0</span>..<span class="number">3</span>).into_iter());
<span class="kw">let </span>m = Matrix2x3::from_iterator((<span class="number">0</span>..<span class="number">6</span>).into_iter());
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_iterator(<span class="number">2</span>, <span class="number">3</span>, (<span class="number">0</span>..<span class="number">6</span>).into_iter());

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_fn-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#633-636">Source</a><h4 class="code-header">pub fn <a href="#method.from_fn-2" class="fn">from_fn</a>&lt;F&gt;(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; T,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector filled with the results of a function applied to each of its
component coordinates.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_fn(|i, <span class="kw">_</span>| i);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_fn(<span class="number">3</span>, |i, <span class="kw">_</span>| i);
<span class="kw">let </span>m = Matrix2x3::from_fn(|i, j| i * <span class="number">3 </span>+ j);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_fn(<span class="number">2</span>, <span class="number">3</span>, |i, j| i * <span class="number">3 </span>+ j);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">1 </span>&amp;&amp; m.m13 == <span class="number">2 </span>&amp;&amp;
        m.m21 == <span class="number">3 </span>&amp;&amp; m.m22 == <span class="number">4 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">4 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.identity-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#633-636">Source</a><h4 class="code-header">pub fn <a href="#method.identity-2" class="fn">identity</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,</div></h4></section></summary><div class="docblock"><p>Creates an identity matrix. If the matrix is not square, the largest square
submatrix (starting at the first row and column) is set to the identity while all
other entries are set to zero.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::&lt;f32&gt;::identity();
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::&lt;f32&gt;::identity(<span class="number">2</span>, <span class="number">3</span>);

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">1.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_diagonal_element-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#633-636">Source</a><h4 class="code-header">pub fn <a href="#method.from_diagonal_element-2" class="fn">from_diagonal_element</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elt: T) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,</div></h4></section></summary><div class="docblock"><p>Creates a matrix filled with its diagonal filled with <code>elt</code> and all other
components set to zero.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::from_diagonal_element(<span class="number">5.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_diagonal_element(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5.0</span>);

<span class="macro">assert!</span>(m.m11 == <span class="number">5.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">5.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">5.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">5.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_partial_diagonal-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#633-636">Source</a><h4 class="code-header">pub fn <a href="#method.from_partial_diagonal-2" class="fn">from_partial_diagonal</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elts: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a new matrix that may be rectangular. The first <code>elts.len()</code> diagonal
elements are filled with the content of <code>elts</code>. Others are set to 0.</p>
<p>Panics if <code>elts.len()</code> is larger than the minimum among <code>nrows</code> and <code>ncols</code>.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix3::from_partial_diagonal(<span class="kw-2">&amp;</span>[<span class="number">1.0</span>, <span class="number">2.0</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_partial_diagonal(<span class="number">3</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">1.0</span>, <span class="number">2.0</span>]);

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">0.0 </span>&amp;&amp;
        m.m31 == <span class="number">0.0 </span>&amp;&amp; m.m32 == <span class="number">0.0 </span>&amp;&amp; m.m33 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">2</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">2</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">2</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+Dynamic,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+Dynamic%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#640-648">Source</a><a href="#impl-Matrix%3CT,+Dynamic,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+Dynamic%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;,</div></h3><div class="docblock"><h4 id="constructors-of-fully-dynamic-matrices"><a class="doc-anchor" href="#constructors-of-fully-dynamic-matrices">§</a>Constructors of fully dynamic matrices</h4></div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_element-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#644-647">Source</a><h4 class="code-header">pub fn <a href="#method.from_element-3" class="fn">from_element</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>elem</code>.</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_element(<span class="number">2.0</span>);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_element(<span class="number">3</span>, <span class="number">2.0</span>);
<span class="kw">let </span>m = Matrix2x3::from_element(<span class="number">2.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_element(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2.0</span>);

<span class="macro">assert!</span>(v.x == <span class="number">2.0 </span>&amp;&amp; v.y == <span class="number">2.0 </span>&amp;&amp; v.z == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">2.0 </span>&amp;&amp; m.m12 == <span class="number">2.0 </span>&amp;&amp; m.m13 == <span class="number">2.0 </span>&amp;&amp;
        m.m21 == <span class="number">2.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">2.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#644-647">Source</a><h4 class="code-header">pub fn <a href="#method.repeat-3" class="fn">repeat</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>elem</code>.</p>
<p>Same as <code>.from_element</code>.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::repeat(<span class="number">2.0</span>);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::repeat(<span class="number">3</span>, <span class="number">2.0</span>);
<span class="kw">let </span>m = Matrix2x3::repeat(<span class="number">2.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::repeat(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2.0</span>);

<span class="macro">assert!</span>(v.x == <span class="number">2.0 </span>&amp;&amp; v.y == <span class="number">2.0 </span>&amp;&amp; v.z == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">2.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">2.0 </span>&amp;&amp; m.m12 == <span class="number">2.0 </span>&amp;&amp; m.m13 == <span class="number">2.0 </span>&amp;&amp;
        m.m21 == <span class="number">2.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">2.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">2.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.zeros-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#644-647">Source</a><h4 class="code-header">pub fn <a href="#method.zeros-3" class="fn">zeros</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements set to <code>0</code>.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::&lt;f32&gt;::zeros();
<span class="comment">// The argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::&lt;f32&gt;::zeros(<span class="number">3</span>);
<span class="kw">let </span>m = Matrix2x3::&lt;f32&gt;::zeros();
<span class="comment">// The two arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::&lt;f32&gt;::zeros(<span class="number">2</span>, <span class="number">3</span>);

<span class="macro">assert!</span>(v.x == <span class="number">0.0 </span>&amp;&amp; v.y == <span class="number">0.0 </span>&amp;&amp; v.z == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0.0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">0.0 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">0.0</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">0.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_iterator-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#644-647">Source</a><h4 class="code-header">pub fn <a href="#method.from_iterator-3" class="fn">from_iterator</a>&lt;I&gt;(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, iter: I) -&gt; Self<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector with all its elements filled by an iterator.</p>
<p>The output matrix is filled column-by-column.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_iterator((<span class="number">0</span>..<span class="number">3</span>).into_iter());
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_iterator(<span class="number">3</span>, (<span class="number">0</span>..<span class="number">3</span>).into_iter());
<span class="kw">let </span>m = Matrix2x3::from_iterator((<span class="number">0</span>..<span class="number">6</span>).into_iter());
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_iterator(<span class="number">2</span>, <span class="number">3</span>, (<span class="number">0</span>..<span class="number">6</span>).into_iter());

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_fn-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#644-647">Source</a><h4 class="code-header">pub fn <a href="#method.from_fn-3" class="fn">from_fn</a>&lt;F&gt;(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; T,</div></h4></section></summary><div class="docblock"><p>Creates a matrix or vector filled with the results of a function applied to each of its
component coordinates.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_fn(|i, <span class="kw">_</span>| i);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_fn(<span class="number">3</span>, |i, <span class="kw">_</span>| i);
<span class="kw">let </span>m = Matrix2x3::from_fn(|i, j| i * <span class="number">3 </span>+ j);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_fn(<span class="number">2</span>, <span class="number">3</span>, |i, j| i * <span class="number">3 </span>+ j);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">1 </span>&amp;&amp; m.m13 == <span class="number">2 </span>&amp;&amp;
        m.m21 == <span class="number">3 </span>&amp;&amp; m.m22 == <span class="number">4 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">4 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.identity-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#644-647">Source</a><h4 class="code-header">pub fn <a href="#method.identity-3" class="fn">identity</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,</div></h4></section></summary><div class="docblock"><p>Creates an identity matrix. If the matrix is not square, the largest square
submatrix (starting at the first row and column) is set to the identity while all
other entries are set to zero.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::&lt;f32&gt;::identity();
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::&lt;f32&gt;::identity(<span class="number">2</span>, <span class="number">3</span>);

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">1.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_diagonal_element-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#644-647">Source</a><h4 class="code-header">pub fn <a href="#method.from_diagonal_element-3" class="fn">from_diagonal_element</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elt: T) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>,</div></h4></section></summary><div class="docblock"><p>Creates a matrix filled with its diagonal filled with <code>elt</code> and all other
components set to zero.</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::from_diagonal_element(<span class="number">5.0</span>);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_diagonal_element(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5.0</span>);

<span class="macro">assert!</span>(m.m11 == <span class="number">5.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">5.0 </span>&amp;&amp; m.m23 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">5.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">5.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_partial_diagonal-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#644-647">Source</a><h4 class="code-header">pub fn <a href="#method.from_partial_diagonal-3" class="fn">from_partial_diagonal</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, elts: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,</div></h4></section></summary><div class="docblock"><p>Creates a new matrix that may be rectangular. The first <code>elts.len()</code> diagonal
elements are filled with the content of <code>elts</code>. Others are set to 0.</p>
<p>Panics if <code>elts.len()</code> is larger than the minimum among <code>nrows</code> and <code>ncols</code>.</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix3::from_partial_diagonal(<span class="kw-2">&amp;</span>[<span class="number">1.0</span>, <span class="number">2.0</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_partial_diagonal(<span class="number">3</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">1.0</span>, <span class="number">2.0</span>]);

<span class="macro">assert!</span>(m.m11 == <span class="number">1.0 </span>&amp;&amp; m.m12 == <span class="number">0.0 </span>&amp;&amp; m.m13 == <span class="number">0.0 </span>&amp;&amp;
        m.m21 == <span class="number">0.0 </span>&amp;&amp; m.m22 == <span class="number">2.0 </span>&amp;&amp; m.m23 == <span class="number">0.0 </span>&amp;&amp;
        m.m31 == <span class="number">0.0 </span>&amp;&amp; m.m32 == <span class="number">0.0 </span>&amp;&amp; m.m33 == <span class="number">0.0</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">1.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">2.0 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">0.0 </span>&amp;&amp;
        dm[(<span class="number">2</span>, <span class="number">0</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">2</span>, <span class="number">1</span>)] == <span class="number">0.0 </span>&amp;&amp; dm[(<span class="number">2</span>, <span class="number">2</span>)] == <span class="number">0.0</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E-2" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#747-750">Source</a><a href="#impl-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>, R: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>, C: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_row_slice" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#747-750">Source</a><h4 class="code-header">pub fn <a href="#method.from_row_slice" class="fn">from_row_slice</a>(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with its elements filled with the components provided by a slice
in row-major order.</p>
<p>The order of elements in the slice must follow the usual mathematic writing, i.e.,
row-by-row.</p>
<h5 id="example-36"><a class="doc-anchor" href="#example-36">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="kw">let </span>m = Matrix2x3::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_row_slice(<span class="number">2</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">1 </span>&amp;&amp; m.m13 == <span class="number">2 </span>&amp;&amp;
        m.m21 == <span class="number">3 </span>&amp;&amp; m.m22 == <span class="number">4 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">4 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_column_slice" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#747-750">Source</a><h4 class="code-header">pub fn <a href="#method.from_column_slice" class="fn">from_column_slice</a>(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with its elements filled with the components provided by a slice
in column-major order.</p>
<h5 id="example-37"><a class="doc-anchor" href="#example-37">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="kw">let </span>m = Matrix2x3::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_column_slice(<span class="number">2</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_vec" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#747-750">Source</a><h4 class="code-header">pub fn <a href="#method.from_vec" class="fn">from_vec</a>(data: <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix backed by a given <code>Vec</code>.</p>
<p>The output matrix is filled column-by-column.</p>
<h5 id="example-38"><a class="doc-anchor" href="#example-38">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::from_vec(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);


<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_vec(<span class="number">2</span>, <span class="number">3</span>, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+R,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+R,+Dynamic%3E%3E::Buffer%3E-1" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#752-755">Source</a><a href="#impl-Matrix%3CT,+R,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+R,+Dynamic%3E%3E::Buffer%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>, R: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_row_slice-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#752-755">Source</a><h4 class="code-header">pub fn <a href="#method.from_row_slice-1" class="fn">from_row_slice</a>(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with its elements filled with the components provided by a slice
in row-major order.</p>
<p>The order of elements in the slice must follow the usual mathematic writing, i.e.,
row-by-row.</p>
<h5 id="example-39"><a class="doc-anchor" href="#example-39">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="kw">let </span>m = Matrix2x3::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_row_slice(<span class="number">2</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">1 </span>&amp;&amp; m.m13 == <span class="number">2 </span>&amp;&amp;
        m.m21 == <span class="number">3 </span>&amp;&amp; m.m22 == <span class="number">4 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">4 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_column_slice-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#752-755">Source</a><h4 class="code-header">pub fn <a href="#method.from_column_slice-1" class="fn">from_column_slice</a>(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with its elements filled with the components provided by a slice
in column-major order.</p>
<h5 id="example-40"><a class="doc-anchor" href="#example-40">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="kw">let </span>m = Matrix2x3::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_column_slice(<span class="number">2</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_vec-1" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#752-755">Source</a><h4 class="code-header">pub fn <a href="#method.from_vec-1" class="fn">from_vec</a>(data: <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix backed by a given <code>Vec</code>.</p>
<p>The output matrix is filled column-by-column.</p>
<h5 id="example-41"><a class="doc-anchor" href="#example-41">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::from_vec(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);


<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_vec(<span class="number">2</span>, <span class="number">3</span>, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E-1" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#757-760">Source</a><a href="#impl-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>, C: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_row_slice-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#757-760">Source</a><h4 class="code-header">pub fn <a href="#method.from_row_slice-2" class="fn">from_row_slice</a>(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with its elements filled with the components provided by a slice
in row-major order.</p>
<p>The order of elements in the slice must follow the usual mathematic writing, i.e.,
row-by-row.</p>
<h5 id="example-42"><a class="doc-anchor" href="#example-42">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="kw">let </span>m = Matrix2x3::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_row_slice(<span class="number">2</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">1 </span>&amp;&amp; m.m13 == <span class="number">2 </span>&amp;&amp;
        m.m21 == <span class="number">3 </span>&amp;&amp; m.m22 == <span class="number">4 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">4 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_column_slice-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#757-760">Source</a><h4 class="code-header">pub fn <a href="#method.from_column_slice-2" class="fn">from_column_slice</a>(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with its elements filled with the components provided by a slice
in column-major order.</p>
<h5 id="example-43"><a class="doc-anchor" href="#example-43">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="kw">let </span>m = Matrix2x3::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_column_slice(<span class="number">2</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_vec-2" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#757-760">Source</a><h4 class="code-header">pub fn <a href="#method.from_vec-2" class="fn">from_vec</a>(data: <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix backed by a given <code>Vec</code>.</p>
<p>The output matrix is filled column-by-column.</p>
<h5 id="example-44"><a class="doc-anchor" href="#example-44">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::from_vec(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);


<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_vec(<span class="number">2</span>, <span class="number">3</span>, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+Dynamic,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+Dynamic%3E%3E::Buffer%3E-1" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#762-765">Source</a><a href="#impl-Matrix%3CT,+Dynamic,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+Dynamic%3E%3E::Buffer%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_row_slice-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#762-765">Source</a><h4 class="code-header">pub fn <a href="#method.from_row_slice-3" class="fn">from_row_slice</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with its elements filled with the components provided by a slice
in row-major order.</p>
<p>The order of elements in the slice must follow the usual mathematic writing, i.e.,
row-by-row.</p>
<h5 id="example-45"><a class="doc-anchor" href="#example-45">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="kw">let </span>m = Matrix2x3::from_row_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_row_slice(<span class="number">2</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">1 </span>&amp;&amp; m.m13 == <span class="number">2 </span>&amp;&amp;
        m.m21 == <span class="number">3 </span>&amp;&amp; m.m22 == <span class="number">4 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">2 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">4 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_column_slice-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#762-765">Source</a><h4 class="code-header">pub fn <a href="#method.from_column_slice-3" class="fn">from_column_slice</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.slice.html">[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix with its elements filled with the components provided by a slice
in column-major order.</p>
<h5 id="example-46"><a class="doc-anchor" href="#example-46">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>v = Vector3::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// The additional argument represents the vector dimension.
</span><span class="kw">let </span>dv = DVector::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="kw">let </span>m = Matrix2x3::from_column_slice(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_column_slice(<span class="number">2</span>, <span class="number">3</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(v.x == <span class="number">0 </span>&amp;&amp; v.y == <span class="number">1 </span>&amp;&amp; v.z == <span class="number">2</span>);
<span class="macro">assert!</span>(dv[<span class="number">0</span>] == <span class="number">0 </span>&amp;&amp; dv[<span class="number">1</span>] == <span class="number">1 </span>&amp;&amp; dv[<span class="number">2</span>] == <span class="number">2</span>);
<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);
<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_vec-3" class="method"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#762-765">Source</a><h4 class="code-header">pub fn <a href="#method.from_vec-3" class="fn">from_vec</a>(nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, data: <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a matrix backed by a given <code>Vec</code>.</p>
<p>The output matrix is filled column-by-column.</p>
<h5 id="example-47"><a class="doc-anchor" href="#example-47">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>m = Matrix2x3::from_vec(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(m.m11 == <span class="number">0 </span>&amp;&amp; m.m12 == <span class="number">2 </span>&amp;&amp; m.m13 == <span class="number">4 </span>&amp;&amp;
        m.m21 == <span class="number">1 </span>&amp;&amp; m.m22 == <span class="number">3 </span>&amp;&amp; m.m23 == <span class="number">5</span>);


<span class="comment">// The two additional arguments represent the matrix dimensions.
</span><span class="kw">let </span>dm = DMatrix::from_vec(<span class="number">2</span>, <span class="number">3</span>, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert!</span>(dm[(<span class="number">0</span>, <span class="number">0</span>)] == <span class="number">0 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">1</span>)] == <span class="number">2 </span>&amp;&amp; dm[(<span class="number">0</span>, <span class="number">2</span>)] == <span class="number">4 </span>&amp;&amp;
        dm[(<span class="number">1</span>, <span class="number">0</span>)] == <span class="number">1 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">1</span>)] == <span class="number">3 </span>&amp;&amp; dm[(<span class="number">1</span>, <span class="number">2</span>)] == <span class="number">5</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+Dynamic,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+Dynamic%3E%3E::Buffer%3E-2" class="impl"><a class="src rightside" href="../../src/nalgebra/base/edition.rs.html#1021-1035">Source</a><a href="#impl-Matrix%3CT,+Dynamic,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+Dynamic%3E%3E::Buffer%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;</h3><div class="docblock"><h4 id="in-place-resizing"><a class="doc-anchor" href="#in-place-resizing">§</a>In-place resizing</h4></div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.resize_mut" class="method"><a class="src rightside" href="../../src/nalgebra/base/edition.rs.html#1028-1034">Source</a><h4 class="code-header">pub fn <a href="#method.resize_mut" class="fn">resize_mut</a>(&amp;mut self, new_nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, new_ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, val: T)<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Reallocator.html" title="trait nalgebra::base::allocator::Reallocator">Reallocator</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Resizes this matrix in-place.</p>
<p>The values are copied such that <code>self[(i, j)] == result[(i, j)]</code>. If the result has more
rows and/or columns than <code>self</code>, then the extra rows or columns are filled with <code>val</code>.</p>
<p>Defined only for owned fully-dynamic matrices, i.e., <code>DMatrix</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E-2" class="impl"><a class="src rightside" href="../../src/nalgebra/base/edition.rs.html#1038-1056">Source</a><a href="#impl-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>, C: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.resize_vertically_mut" class="method"><a class="src rightside" href="../../src/nalgebra/base/edition.rs.html#1049-1055">Source</a><h4 class="code-header">pub fn <a href="#method.resize_vertically_mut" class="fn">resize_vertically_mut</a>(&amp;mut self, new_nrows: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, val: T)<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Reallocator.html" title="trait nalgebra::base::allocator::Reallocator">Reallocator</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;,</div></h4></section></summary><div class="docblock"><p>Changes the number of rows of this matrix in-place.</p>
<p>The values are copied such that <code>self[(i, j)] == result[(i, j)]</code>. If the result has more
rows than <code>self</code>, then the extra rows are filled with <code>val</code>.</p>
<p>Defined only for owned matrices with a dynamic number of rows (for example, <code>DVector</code>).</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+R,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+R,+Dynamic%3E%3E::Buffer%3E-2" class="impl"><a class="src rightside" href="../../src/nalgebra/base/edition.rs.html#1059-1077">Source</a><a href="#impl-Matrix%3CT,+R,+Dynamic,+%3CDefaultAllocator+as+Allocator%3CT,+R,+Dynamic%3E%3E::Buffer%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>, R: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.resize_horizontally_mut" class="method"><a class="src rightside" href="../../src/nalgebra/base/edition.rs.html#1070-1076">Source</a><h4 class="code-header">pub fn <a href="#method.resize_horizontally_mut" class="fn">resize_horizontally_mut</a>(&amp;mut self, new_ncols: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, val: T)<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Reallocator.html" title="trait nalgebra::base::allocator::Reallocator">Reallocator</a>&lt;T, R, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, R, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Changes the number of column of this matrix in-place.</p>
<p>The values are copied such that <code>self[(i, j)] == result[(i, j)]</code>. If the result has more
columns than <code>self</code>, then the extra columns are filled with <code>val</code>.</p>
<p>Defined only for owned matrices with a dynamic number of columns (for example, <code>DVector</code>).</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E-2" class="impl"><a class="src rightside" href="../../src/nalgebra/linalg/exp.rs.html#481-551">Source</a><a href="#impl-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../trait.ComplexField.html" title="trait nalgebra::ComplexField">ComplexField</a>, D&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, D, D&gt;<div class="where">where
    D: <a class="trait" href="dimension/trait.DimMin.html" title="trait nalgebra::base::dimension::DimMin">DimMin</a>&lt;D, Output = D&gt;,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, D, D&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>), <a class="type" href="dimension/type.DimMinimum.html" title="type nalgebra::base::dimension::DimMinimum">DimMinimum</a>&lt;D, D&gt;&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, D&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T::<a class="associatedtype" href="../trait.ComplexField.html#associatedtype.RealField" title="type nalgebra::ComplexField::RealField">RealField</a>, D&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T::<a class="associatedtype" href="../trait.ComplexField.html#associatedtype.RealField" title="type nalgebra::ComplexField::RealField">RealField</a>, D, D&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.exp" class="method"><a class="src rightside" href="../../src/nalgebra/linalg/exp.rs.html#492-550">Source</a><h4 class="code-header">pub fn <a href="#method.exp" class="fn">exp</a>(&amp;self) -&gt; Self</h4></section></summary><div class="docblock"><p>Computes exponential of this matrix</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Bounded-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#799-813">Source</a><a href="#impl-Bounded-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, R: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>, C: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="trait" href="../../num_traits/bounds/trait.Bounded.html" title="trait num_traits::bounds::Bounded">Bounded</a> for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../num_traits/bounds/trait.Bounded.html" title="trait num_traits::bounds::Bounded">Bounded</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.max_value" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#805-807">Source</a><a href="#method.max_value" class="anchor">§</a><h4 class="code-header">fn <a href="../../num_traits/bounds/trait.Bounded.html#tymethod.max_value" class="fn">max_value</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the largest finite number this type can represent</div></details><details class="toggle method-toggle" open><summary><section id="method.min_value" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#810-812">Source</a><a href="#method.min_value" class="anchor">§</a><h4 class="code-header">fn <a href="../../num_traits/bounds/trait.Bounded.html#tymethod.min_value" class="fn">min_value</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the smallest finite number this type can represent</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+16%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#611-643">Source</a><a href="#impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+16%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, R: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>, C: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[<a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C, &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a>&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">16</a>]&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">16</a>]&gt; + <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../simba/simd/simd_value/trait.PrimitiveSimdValue.html" title="trait simba::simd::simd_value::PrimitiveSimdValue">PrimitiveSimdValue</a>,
    T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#618-642">Source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(arr: [<a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">16</a>]) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+2%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#544-559">Source</a><a href="#impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+2%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, R: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>, C: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[<a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C, &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a>&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">2</a>]&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">2</a>]&gt; + <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../simba/simd/simd_value/trait.PrimitiveSimdValue.html" title="trait simba::simd::simd_value::PrimitiveSimdValue">PrimitiveSimdValue</a>,
    T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#552-558">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(arr: [<a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">2</a>]) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+4%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#561-582">Source</a><a href="#impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+4%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, R: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>, C: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[<a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C, &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a>&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">4</a>]&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">4</a>]&gt; + <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../simba/simd/simd_value/trait.PrimitiveSimdValue.html" title="trait simba::simd::simd_value::PrimitiveSimdValue">PrimitiveSimdValue</a>,
    T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#569-581">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(arr: [<a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">4</a>]) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+8%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#584-609">Source</a><a href="#impl-From%3C%5BMatrix%3C%3CT+as+SimdValue%3E::Element,+R,+C,+%3CDefaultAllocator+as+Allocator%3C%3CT+as+SimdValue%3E::Element,+R,+C%3E%3E::Buffer%3E;+8%5D%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, R: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>, C: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[<a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C, &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a>&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">8</a>]&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">8</a>]&gt; + <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../simba/simd/simd_value/trait.PrimitiveSimdValue.html" title="trait simba::simd::simd_value::PrimitiveSimdValue">PrimitiveSimdValue</a>,
    T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#592-608">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(arr: [<a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.array.html">8</a>]) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CIsometry%3CT,+R,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/geometry/isometry_conversion.rs.html#189-200">Source</a><a href="#impl-From%3CIsometry%3CT,+R,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../trait.SimdRealField.html" title="trait nalgebra::SimdRealField">SimdRealField</a>, R, const D: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../geometry/struct.Isometry.html" title="struct nalgebra::geometry::Isometry">Isometry</a>&lt;T, R, D&gt;&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;<div class="where">where
    <a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;: <a class="trait" href="dimension/trait.DimNameAdd.html" title="trait nalgebra::base::dimension::DimNameAdd">DimNameAdd</a>&lt;<a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;,
    R: <a class="trait" href="../../simba/scalar/subset/trait.SubsetOf.html" title="trait simba::scalar::subset::SubsetOf">SubsetOf</a>&lt;<a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;&gt;,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/geometry/isometry_conversion.rs.html#197-199">Source</a><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(iso: <a class="struct" href="../geometry/struct.Isometry.html" title="struct nalgebra::geometry::Isometry">Isometry</a>&lt;T, R, D&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CScale%3CT,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/geometry/scale_conversion.rs.html#112-124">Source</a><a href="#impl-From%3CScale%3CT,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>, const D: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../geometry/struct.Scale.html" title="struct nalgebra::geometry::Scale">Scale</a>&lt;T, D&gt;&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;<div class="where">where
    <a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;: <a class="trait" href="dimension/trait.DimNameAdd.html" title="trait nalgebra::base::dimension::DimNameAdd">DimNameAdd</a>&lt;<a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/geometry/scale_conversion.rs.html#121-123">Source</a><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="../geometry/struct.Scale.html" title="struct nalgebra::geometry::Scale">Scale</a>&lt;T, D&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSimilarity%3CT,+R,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/geometry/similarity_conversion.rs.html#176-187">Source</a><a href="#impl-From%3CSimilarity%3CT,+R,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../trait.SimdRealField.html" title="trait nalgebra::SimdRealField">SimdRealField</a>, R, const D: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../geometry/struct.Similarity.html" title="struct nalgebra::geometry::Similarity">Similarity</a>&lt;T, R, D&gt;&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;<div class="where">where
    <a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;: <a class="trait" href="dimension/trait.DimNameAdd.html" title="trait nalgebra::base::dimension::DimNameAdd">DimNameAdd</a>&lt;<a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;,
    R: <a class="trait" href="../../simba/scalar/subset/trait.SubsetOf.html" title="trait simba::scalar::subset::SubsetOf">SubsetOf</a>&lt;<a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;&gt;,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/geometry/similarity_conversion.rs.html#184-186">Source</a><a href="#method.from-7" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(sim: <a class="struct" href="../geometry/struct.Similarity.html" title="struct nalgebra::geometry::Similarity">Similarity</a>&lt;T, R, D&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTransform%3CT,+C,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/geometry/transform_conversion.rs.html#68-79">Source</a><a href="#impl-From%3CTransform%3CT,+C,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../trait.RealField.html" title="trait nalgebra::RealField">RealField</a>, C, const D: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../geometry/struct.Transform.html" title="struct nalgebra::geometry::Transform">Transform</a>&lt;T, C, D&gt;&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;<div class="where">where
    <a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;: <a class="trait" href="dimension/trait.DimNameAdd.html" title="trait nalgebra::base::dimension::DimNameAdd">DimNameAdd</a>&lt;<a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;,
    C: <a class="trait" href="../geometry/trait.TCategory.html" title="trait nalgebra::geometry::TCategory">TCategory</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-8" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/geometry/transform_conversion.rs.html#76-78">Source</a><a href="#method.from-8" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="../geometry/struct.Transform.html" title="struct nalgebra::geometry::Transform">Transform</a>&lt;T, C, D&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTranslation%3CT,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/geometry/translation_conversion.rs.html#183-194">Source</a><a href="#impl-From%3CTranslation%3CT,+D%3E%3E-for-Matrix%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CDefaultAllocator+as+Allocator%3CT,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output,+%3CConst%3CD%3E+as+DimNameAdd%3CConst%3C1%3E%3E%3E::Output%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a>, const D: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../geometry/struct.Translation.html" title="struct nalgebra::geometry::Translation">Translation</a>&lt;T, D&gt;&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt;<div class="where">where
    <a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;: <a class="trait" href="dimension/trait.DimNameAdd.html" title="trait nalgebra::base::dimension::DimNameAdd">DimNameAdd</a>&lt;<a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;, <a class="type" href="dimension/type.DimNameSum.html" title="type nalgebra::base::dimension::DimNameSum">DimNameSum</a>&lt;<a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;, <a class="type" href="dimension/type.U1.html" title="type nalgebra::base::dimension::U1">U1</a>&gt;&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="struct" href="dimension/struct.Const.html" title="struct nalgebra::base::dimension::Const">Const</a>&lt;D&gt;&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/geometry/translation_conversion.rs.html#191-193">Source</a><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="../geometry/struct.Translation.html" title="struct nalgebra::geometry::Translation">Translation</a>&lt;T, D&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Normed-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/norm.rs.html#460-485">Source</a><a href="#impl-Normed-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../trait.SimdComplexField.html" title="trait nalgebra::SimdComplexField">SimdComplexField</a>, R: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>, C: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="trait" href="trait.Normed.html" title="trait nalgebra::base::Normed">Normed</a> for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Norm" class="associatedtype trait-impl"><a class="src rightside" href="../../src/nalgebra/base/norm.rs.html#464">Source</a><a href="#associatedtype.Norm" class="anchor">§</a><h4 class="code-header">type <a href="trait.Normed.html#associatedtype.Norm" class="associatedtype">Norm</a> = &lt;T as <a class="trait" href="../trait.SimdComplexField.html" title="trait nalgebra::SimdComplexField">SimdComplexField</a>&gt;::<a class="associatedtype" href="../trait.SimdComplexField.html#associatedtype.SimdRealField" title="type nalgebra::SimdComplexField::SimdRealField">SimdRealField</a></h4></section></summary><div class='docblock'>The type of the norm.</div></details><details class="toggle method-toggle" open><summary><section id="method.norm" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/norm.rs.html#467-469">Source</a><a href="#method.norm" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Normed.html#tymethod.norm" class="fn">norm</a>(&amp;self) -&gt; T::<a class="associatedtype" href="../trait.SimdComplexField.html#associatedtype.SimdRealField" title="type nalgebra::SimdComplexField::SimdRealField">SimdRealField</a></h4></section></summary><div class='docblock'>Computes the norm.</div></details><details class="toggle method-toggle" open><summary><section id="method.norm_squared" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/norm.rs.html#472-474">Source</a><a href="#method.norm_squared" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Normed.html#tymethod.norm_squared" class="fn">norm_squared</a>(&amp;self) -&gt; T::<a class="associatedtype" href="../trait.SimdComplexField.html#associatedtype.SimdRealField" title="type nalgebra::SimdComplexField::SimdRealField">SimdRealField</a></h4></section></summary><div class='docblock'>Computes the squared norm.</div></details><details class="toggle method-toggle" open><summary><section id="method.scale_mut" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/norm.rs.html#477-479">Source</a><a href="#method.scale_mut" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Normed.html#tymethod.scale_mut" class="fn">scale_mut</a>(&amp;mut self, n: Self::<a class="associatedtype" href="trait.Normed.html#associatedtype.Norm" title="type nalgebra::base::Normed::Norm">Norm</a>)</h4></section></summary><div class='docblock'>Multiply <code>self</code> by n.</div></details><details class="toggle method-toggle" open><summary><section id="method.unscale_mut" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/norm.rs.html#482-484">Source</a><a href="#method.unscale_mut" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Normed.html#tymethod.unscale_mut" class="fn">unscale_mut</a>(&amp;mut self, n: Self::<a class="associatedtype" href="trait.Normed.html#associatedtype.Norm" title="type nalgebra::base::Normed::Norm">Norm</a>)</h4></section></summary><div class='docblock'>Divides <code>self</code> by n.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-One-for-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#788-797">Source</a><a href="#impl-One-for-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, D: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a> for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, D, D&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a> + <a class="trait" href="../trait.ClosedMul.html" title="trait nalgebra::ClosedMul">ClosedMul</a> + <a class="trait" href="../trait.ClosedAdd.html" title="trait nalgebra::ClosedAdd">ClosedAdd</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, D, D&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.one" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#794-796">Source</a><a href="#method.one" class="anchor">§</a><h4 class="code-header">fn <a href="../../num_traits/identities/trait.One.html#tymethod.one" class="fn">one</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the multiplicative identity element of <code>Self</code>, <code>1</code>. <a href="../../num_traits/identities/trait.One.html#tymethod.one">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.set_one" class="method trait-impl"><a class="src rightside" href="../../src/num_traits/identities.rs.html#118">Source</a><a href="#method.set_one" class="anchor">§</a><h4 class="code-header">fn <a href="../../num_traits/identities/trait.One.html#method.set_one" class="fn">set_one</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Sets <code>self</code> to the multiplicative identity element of <code>Self</code>, <code>1</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.is_one" class="method trait-impl"><a class="src rightside" href="../../src/num_traits/identities.rs.html#128-130">Source</a><a href="#method.is_one" class="anchor">§</a><h4 class="code-header">fn <a href="../../num_traits/identities/trait.One.html#method.is_one" class="fn">is_one</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,</div></h4></section></summary><div class='docblock'>Returns <code>true</code> if <code>self</code> is equal to the multiplicative identity. <a href="../../num_traits/identities/trait.One.html#method.is_one">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Product%3C%26Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E%3E-for-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#846-854">Source</a><a href="#impl-Product%3C%26Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E%3E-for-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, D: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Product.html" title="trait core::iter::traits::accum::Product">Product</a>&lt;&amp;'a <a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;T, D, D, &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, D, D&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a>&gt;&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, D, D&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a> + <a class="trait" href="../trait.ClosedMul.html" title="trait nalgebra::ClosedMul">ClosedMul</a> + <a class="trait" href="../trait.ClosedAdd.html" title="trait nalgebra::ClosedAdd">ClosedAdd</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, D, D&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.product-1" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#851-853">Source</a><a href="#method.product-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Product.html#tymethod.product" class="fn">product</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = &amp;'a <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, D, D&gt;&gt;&gt;(
    iter: I,
) -&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, D, D&gt;</h4></section></summary><div class='docblock'>Takes an iterator and generates <code>Self</code> from the elements by multiplying
the items.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Product-for-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#836-844">Source</a><a href="#impl-Product-for-Matrix%3CT,+D,+D,+%3CDefaultAllocator+as+Allocator%3CT,+D,+D%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, D: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Product.html" title="trait core::iter::traits::accum::Product">Product</a> for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, D, D&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../../num_traits/identities/trait.One.html" title="trait num_traits::identities::One">One</a> + <a class="trait" href="../trait.ClosedMul.html" title="trait nalgebra::ClosedMul">ClosedMul</a> + <a class="trait" href="../trait.ClosedAdd.html" title="trait nalgebra::ClosedAdd">ClosedAdd</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, D, D&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.product" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#841-843">Source</a><a href="#method.product" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Product.html#tymethod.product" class="fn">product</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, D, D&gt;&gt;&gt;(iter: I) -&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, D, D&gt;</h4></section></summary><div class='docblock'>Takes an iterator and generates <code>Self</code> from the elements by multiplying
the items.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SimdValue-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/matrix_simba.rs.html#12-60">Source</a><a href="#impl-SimdValue-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, R, C&gt; <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a> for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>,
    R: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>,
    C: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>,
    T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Element" class="associatedtype trait-impl"><a class="src rightside" href="../../src/nalgebra/base/matrix_simba.rs.html#20">Source</a><a href="#associatedtype.Element" class="anchor">§</a><h4 class="code-header">type <a href="../trait.SimdValue.html#associatedtype.Element" class="associatedtype">Element</a> = <a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C, &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;&lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, R, C&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a>&gt;</h4></section></summary><div class='docblock'>The type of the elements of each lane of this SIMD value.</div></details><details class="toggle" open><summary><section id="associatedtype.SimdBool" class="associatedtype trait-impl"><a class="src rightside" href="../../src/nalgebra/base/matrix_simba.rs.html#21">Source</a><a href="#associatedtype.SimdBool" class="anchor">§</a><h4 class="code-header">type <a href="../trait.SimdValue.html#associatedtype.SimdBool" class="associatedtype">SimdBool</a> = &lt;T as <a class="trait" href="../trait.SimdValue.html" title="trait nalgebra::SimdValue">SimdValue</a>&gt;::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.SimdBool" title="type nalgebra::SimdValue::SimdBool">SimdBool</a></h4></section></summary><div class='docblock'>Type of the result of comparing two SIMD values like <code>self</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.lanes" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/matrix_simba.rs.html#24-26">Source</a><a href="#method.lanes" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.SimdValue.html#tymethod.lanes" class="fn">lanes</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>The number of lanes of this SIMD value.</div></details><details class="toggle method-toggle" open><summary><section id="method.splat" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/matrix_simba.rs.html#29-31">Source</a><a href="#method.splat" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.SimdValue.html#tymethod.splat" class="fn">splat</a>(val: Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>) -&gt; Self</h4></section></summary><div class='docblock'>Initializes an SIMD value with each lanes set to <code>val</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.extract" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/matrix_simba.rs.html#34-36">Source</a><a href="#method.extract" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.SimdValue.html#tymethod.extract" class="fn">extract</a>(&amp;self, i: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a></h4></section></summary><div class='docblock'>Extracts the i-th lane of <code>self</code>. <a href="../trait.SimdValue.html#tymethod.extract">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extract_unchecked" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/matrix_simba.rs.html#39-41">Source</a><a href="#method.extract_unchecked" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../trait.SimdValue.html#tymethod.extract_unchecked" class="fn">extract_unchecked</a>(&amp;self, i: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>) -&gt; Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a></h4></section></summary><div class='docblock'>Extracts the i-th lane of <code>self</code> without bound-checking.</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/matrix_simba.rs.html#44-48">Source</a><a href="#method.replace" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.SimdValue.html#tymethod.replace" class="fn">replace</a>(&amp;mut self, i: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, val: Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>)</h4></section></summary><div class='docblock'>Replaces the i-th lane of <code>self</code> by <code>val</code>. <a href="../trait.SimdValue.html#tymethod.replace">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.replace_unchecked" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/matrix_simba.rs.html#51-55">Source</a><a href="#method.replace_unchecked" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../trait.SimdValue.html#tymethod.replace_unchecked" class="fn">replace_unchecked</a>(&amp;mut self, i: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>, val: Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>)</h4></section></summary><div class='docblock'>Replaces the i-th lane of <code>self</code> by <code>val</code> without bound-checking.</div></details><details class="toggle method-toggle" open><summary><section id="method.select" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/matrix_simba.rs.html#57-59">Source</a><a href="#method.select" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.SimdValue.html#tymethod.select" class="fn">select</a>(self, cond: Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.SimdBool" title="type nalgebra::SimdValue::SimdBool">SimdBool</a>, other: Self) -&gt; Self</h4></section></summary><div class='docblock'>Merges <code>self</code> and <code>other</code> depending on the lanes of <code>cond</code>. <a href="../trait.SimdValue.html#tymethod.select">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.map_lanes" class="method trait-impl"><a class="src rightside" href="../../src/simba/simd/simd_value.rs.html#39-41">Source</a><a href="#method.map_lanes" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.SimdValue.html#method.map_lanes" class="fn">map_lanes</a>(self, f: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>) -&gt; Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class='docblock'>Applies a function to each lane of <code>self</code>. <a href="../trait.SimdValue.html#method.map_lanes">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.zip_map_lanes" class="method trait-impl"><a class="src rightside" href="../../src/simba/simd/simd_value.rs.html#58-64">Source</a><a href="#method.zip_map_lanes" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.SimdValue.html#method.zip_map_lanes" class="fn">zip_map_lanes</a>(
    self,
    b: Self,
    f: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>, Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>) -&gt; Self::<a class="associatedtype" href="../trait.SimdValue.html#associatedtype.Element" title="type nalgebra::SimdValue::Element">Element</a>,
) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class='docblock'>Applies a function to each lane of <code>self</code> paired with the corresponding lane of <code>b</code>. <a href="../trait.SimdValue.html#method.zip_map_lanes">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubsetOf%3CMatrix%3CT2,+R2,+C2,+%3CDefaultAllocator+as+Allocator%3CT2,+R2,+C2%3E%3E::Buffer%3E%3E-for-Matrix%3CT1,+R1,+C1,+%3CDefaultAllocator+as+Allocator%3CT1,+R1,+C1%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#30-87">Source</a><a href="#impl-SubsetOf%3CMatrix%3CT2,+R2,+C2,+%3CDefaultAllocator+as+Allocator%3CT2,+R2,+C2%3E%3E::Buffer%3E%3E-for-Matrix%3CT1,+R1,+C1,+%3CDefaultAllocator+as+Allocator%3CT1,+R1,+C1%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T1, T2, R1, C1, R2, C2&gt; <a class="trait" href="../../simba/scalar/subset/trait.SubsetOf.html" title="trait simba::scalar::subset::SubsetOf">SubsetOf</a>&lt;<a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;T2, R2, C2, &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T2, R2, C2&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a>&gt;&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T1, R1, C1&gt;<div class="where">where
    R1: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>,
    C1: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>,
    R2: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>,
    C2: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>,
    T1: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a>,
    T2: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../simba/scalar/subset/trait.SupersetOf.html" title="trait simba::scalar::subset::SupersetOf">SupersetOf</a>&lt;T1&gt;,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T2, R2, C2&gt; + <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T1, R1, C1&gt; + <a class="trait" href="allocator/trait.SameShapeAllocator.html" title="trait nalgebra::base::allocator::SameShapeAllocator">SameShapeAllocator</a>&lt;T1, R1, C1, R2, C2&gt;,
    <a class="struct" href="constraint/struct.ShapeConstraint.html" title="struct nalgebra::base::constraint::ShapeConstraint">ShapeConstraint</a>: <a class="trait" href="constraint/trait.SameNumberOfRows.html" title="trait nalgebra::base::constraint::SameNumberOfRows">SameNumberOfRows</a>&lt;R1, R2&gt; + <a class="trait" href="constraint/trait.SameNumberOfColumns.html" title="trait nalgebra::base::constraint::SameNumberOfColumns">SameNumberOfColumns</a>&lt;C1, C2&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_superset" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#43-61">Source</a><a href="#method.to_superset" class="anchor">§</a><h4 class="code-header">fn <a href="../../simba/scalar/subset/trait.SubsetOf.html#tymethod.to_superset" class="fn">to_superset</a>(&amp;self) -&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T2, R2, C2&gt;</h4></section></summary><div class='docblock'>The inclusion map: converts <code>self</code> to the equivalent element of its superset.</div></details><details class="toggle method-toggle" open><summary><section id="method.is_in_subset" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#64-66">Source</a><a href="#method.is_in_subset" class="anchor">§</a><h4 class="code-header">fn <a href="../../simba/scalar/subset/trait.SubsetOf.html#tymethod.is_in_subset" class="fn">is_in_subset</a>(m: &amp;<a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T2, R2, C2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Checks if <code>element</code> is actually part of the subset <code>Self</code> (and can be converted to it).</div></details><details class="toggle method-toggle" open><summary><section id="method.from_superset_unchecked" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/conversion.rs.html#69-86">Source</a><a href="#method.from_superset_unchecked" class="anchor">§</a><h4 class="code-header">fn <a href="../../simba/scalar/subset/trait.SubsetOf.html#tymethod.from_superset_unchecked" class="fn">from_superset_unchecked</a>(m: &amp;<a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T2, R2, C2&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Use with care! Same as <code>self.to_superset</code> but without any property checks. Always succeeds.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_superset" class="method trait-impl"><a class="src rightside" href="../../src/simba/scalar/subset.rs.html#32">Source</a><a href="#method.from_superset" class="anchor">§</a><h4 class="code-header">fn <a href="../../simba/scalar/subset/trait.SubsetOf.html#method.from_superset" class="fn">from_superset</a>(element: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;T</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>The inverse inclusion map: attempts to construct <code>self</code> from the equivalent element of its
superset. <a href="../../simba/scalar/subset/trait.SubsetOf.html#method.from_superset">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sum%3C%26Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E%3E-for-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#417-445">Source</a><a href="#impl-Sum%3C%26Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E%3E-for-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, C: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Sum.html" title="trait core::iter::traits::accum::Sum">Sum</a>&lt;&amp;'a <a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C, &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a>&gt;&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../trait.ClosedAdd.html" title="trait nalgebra::ClosedAdd">ClosedAdd</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sum-3" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#438-444">Source</a><a href="#method.sum-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Sum.html#tymethod.sum" class="fn">sum</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = &amp;'a <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;&gt;&gt;(
    iter: I,
) -&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;</h4></section></summary><div class="docblock"><h5 id="example-49"><a class="doc-anchor" href="#example-49">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = <span class="kw-2">&amp;</span>DVector::repeat(<span class="number">3</span>, <span class="number">1.0f64</span>);

<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[v, v, v].into_iter().sum::&lt;DVector&lt;f64&gt;&gt;(),
           v + v + v);</code></pre></div>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>Panics if the iterator is empty:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">ⓘ</a><pre class="rust rust-example-rendered"><code>iter::empty::&lt;<span class="kw-2">&amp;</span>DMatrix&lt;f64&gt;&gt;().sum::&lt;DMatrix&lt;f64&gt;&gt;(); <span class="comment">// panics!</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sum%3C%26Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#407-415">Source</a><a href="#impl-Sum%3C%26Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E%3E-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, R: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>, C: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Sum.html" title="trait core::iter::traits::accum::Sum">Sum</a>&lt;&amp;'a <a class="struct" href="struct.Matrix.html" title="struct nalgebra::base::Matrix">Matrix</a>&lt;T, R, C, &lt;<a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a> as <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;&gt;::<a class="associatedtype" href="allocator/trait.Allocator.html#associatedtype.Buffer" title="type nalgebra::base::allocator::Allocator::Buffer">Buffer</a>&gt;&gt; for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../trait.ClosedAdd.html" title="trait nalgebra::ClosedAdd">ClosedAdd</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sum-2" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#412-414">Source</a><a href="#method.sum-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Sum.html#tymethod.sum" class="fn">sum</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = &amp;'a <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;&gt;&gt;(iter: I) -&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;</h4></section></summary><div class='docblock'>Takes an iterator and generates <code>Self</code> from the elements by “summing up”
the items.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sum-for-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#377-405">Source</a><a href="#impl-Sum-for-Matrix%3CT,+Dynamic,+C,+%3CDefaultAllocator+as+Allocator%3CT,+Dynamic,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C: <a class="trait" href="dimension/trait.Dim.html" title="trait nalgebra::base::dimension::Dim">Dim</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Sum.html" title="trait core::iter::traits::accum::Sum">Sum</a> for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../trait.ClosedAdd.html" title="trait nalgebra::ClosedAdd">ClosedAdd</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sum-1" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#398-404">Source</a><a href="#method.sum-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Sum.html#tymethod.sum" class="fn">sum</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;&gt;&gt;(
    iter: I,
) -&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, <a class="struct" href="dimension/struct.Dynamic.html" title="struct nalgebra::base::dimension::Dynamic">Dynamic</a>, C&gt;</h4></section></summary><div class="docblock"><h5 id="example-48"><a class="doc-anchor" href="#example-48">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[DVector::repeat(<span class="number">3</span>, <span class="number">1.0f64</span>),
                DVector::repeat(<span class="number">3</span>, <span class="number">1.0f64</span>),
                DVector::repeat(<span class="number">3</span>, <span class="number">1.0f64</span>)].into_iter().sum::&lt;DVector&lt;f64&gt;&gt;(),
           DVector::repeat(<span class="number">3</span>, <span class="number">1.0f64</span>) + DVector::repeat(<span class="number">3</span>, <span class="number">1.0f64</span>) + DVector::repeat(<span class="number">3</span>, <span class="number">1.0f64</span>));</code></pre></div>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if the iterator is empty:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">ⓘ</a><pre class="rust rust-example-rendered"><code>iter::empty::&lt;DMatrix&lt;f64&gt;&gt;().sum::&lt;DMatrix&lt;f64&gt;&gt;(); <span class="comment">// panics!</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sum-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#367-375">Source</a><a href="#impl-Sum-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, R: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>, C: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Sum.html" title="trait core::iter::traits::accum::Sum">Sum</a> for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../trait.ClosedAdd.html" title="trait nalgebra::ClosedAdd">ClosedAdd</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sum" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/ops.rs.html#372-374">Source</a><a href="#method.sum" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/iter/traits/accum/trait.Sum.html#tymethod.sum" class="fn">sum</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;&gt;&gt;(iter: I) -&gt; <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;</h4></section></summary><div class='docblock'>Takes an iterator and generates <code>Self</code> from the elements by “summing up”
the items.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Zero-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#772-786">Source</a><a href="#impl-Zero-for-Matrix%3CT,+R,+C,+%3CDefaultAllocator+as+Allocator%3CT,+R,+C%3E%3E::Buffer%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, R: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>, C: <a class="trait" href="dimension/trait.DimName.html" title="trait nalgebra::base::dimension::DimName">DimName</a>&gt; <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> for <a class="type" href="type.OMatrix.html" title="type nalgebra::base::OMatrix">OMatrix</a>&lt;T, R, C&gt;<div class="where">where
    T: <a class="trait" href="trait.Scalar.html" title="trait nalgebra::base::Scalar">Scalar</a> + <a class="trait" href="../../num_traits/identities/trait.Zero.html" title="trait num_traits::identities::Zero">Zero</a> + <a class="trait" href="../trait.ClosedAdd.html" title="trait nalgebra::ClosedAdd">ClosedAdd</a>,
    <a class="struct" href="default_allocator/struct.DefaultAllocator.html" title="struct nalgebra::base::default_allocator::DefaultAllocator">DefaultAllocator</a>: <a class="trait" href="allocator/trait.Allocator.html" title="trait nalgebra::base::allocator::Allocator">Allocator</a>&lt;T, R, C&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.zero" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#778-780">Source</a><a href="#method.zero" class="anchor">§</a><h4 class="code-header">fn <a href="../../num_traits/identities/trait.Zero.html#tymethod.zero" class="fn">zero</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the additive identity element of <code>Self</code>, <code>0</code>. <a href="../../num_traits/identities/trait.Zero.html#tymethod.zero">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_zero" class="method trait-impl"><a class="src rightside" href="../../src/nalgebra/base/construction.rs.html#783-785">Source</a><a href="#method.is_zero" class="anchor">§</a><h4 class="code-header">fn <a href="../../num_traits/identities/trait.Zero.html#tymethod.is_zero" class="fn">is_zero</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns <code>true</code> if <code>self</code> is equal to the additive identity.</div></details><details class="toggle method-toggle" open><summary><section id="method.set_zero" class="method trait-impl"><a class="src rightside" href="../../src/num_traits/identities.rs.html#23">Source</a><a href="#method.set_zero" class="anchor">§</a><h4 class="code-header">fn <a href="../../num_traits/identities/trait.Zero.html#method.set_zero" class="fn">set_zero</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Sets <code>self</code> to the additive identity element of <code>Self</code>, <code>0</code>.</div></details></div></details></div><script src="../../type.impl/nalgebra/base/struct.Matrix.js" data-self-path="nalgebra::base::alias::OMatrix" async></script></section></div></main></body></html>