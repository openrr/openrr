searchState.loadedDescShard("buf_redux", 0, "Drop-in replacements for buffered I/O types in <code>std::io</code>.\nA drop-in replacement for <code>std::io::BufReader</code> with more …\nA drop-in replacement for <code>std::io::BufWriter</code> with more …\nA deque-like datastructure for managing bytes.\nThe error type for <code>BufWriter::into_inner()</code>, contains the …\nA drop-in replacement for <code>std::io::LineWriter</code> with more …\nA <code>Read</code> adapter for a consumed <code>BufReader</code> which will empty …\nBox the inner reader without losing data.\nGet an immutable slice of the available bytes in this …\nGet a slice over the available bytes in the buffer.\nGet the current number of bytes available in the buffer.\nGet the number of bytes currently in the buffer.\nGet the number of bytes currently in the buffer.\nReturns the number of bytes remaining in the buffer.\nGet a mutable slice representing the available bytes in …\nGet the section of the buffer containing valid data; may …\nGet the total buffer capacity.\nGet the capacty of the inner buffer.\nGet the capacity of the inner buffer.\nReturn the total capacity of this buffer.\nEmpty this buffer by consuming all bytes.\nConsume <code>amt</code> bytes from the head of this buffer.\nCopy data between a <code>BufRead</code> and a <code>Write</code> without an …\nCopy from <code>src</code> to the tail of this buffer. Returns the …\nCopy bytes to <code>out</code> from this buffer, returning the number …\nShorthand for <code>return DoRead(bool)</code> or <code>return DoRead(true)</code> …\nGet the error\nShorthand for <code>return FlushAmt(n)</code> or <code>return FlushAmt(0)</code> …\nReturns the total amount of free space in the buffer, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a mutable reference to the underlying reader.\nGet a mutable reference to the inner writer.\nGet a mutable reference to the inner writer.\nGet an immutable reference to the underlying reader.\nGet a reference to the inner writer.\nGet a reference to the inner writer.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume <code>self</code> and return the inner reader only.\nFlush the buffer and unwrap, returning the inner writer on …\nFlush the buffer and unwrap, returning the inner writer on …\nReturn the underlying reader, releasing the buffer.\nTake the writer.\nConsume <code>self</code> and return both the underlying writer and the …\nConsume <code>self</code> and return both the underlying reader and the …\nConsume <code>self</code> and return both the underlying writer and the …\nFlush the buffer and unwrap, returning the inner writer and\nFlush the buffer and unwrap, returning the inner writer and\nReturns <code>true</code> if the buffer still has some bytes left, <code>false</code>…\nReturns <code>true</code> if there are no bytes in the buffer, false …\nReturn <code>true</code> if this is a ringbuffer.\nReturn the number of bytes currently in this buffer.\nMove data to the start of the buffer, making room at the …\nMove data to the start of the buffer, making room at the …\nMove bytes down in the buffer to maximize usable space.\nCreate a new <code>BufReader</code> wrapping <code>inner</code>, utilizing a buffer …\nCreate a new <code>BufWriter</code> wrapping <code>inner</code> with the default …\nWrap <code>inner</code> with the default buffer capacity.\nCreate a new buffer with a default capacity.\nTypes which can be used to tune the behavior of <code>BufReader</code> …\nInspect the current <code>ReaderPolicy</code>.\nInspect the current <code>WriterPolicy</code>.\nMutate the current <code>ReaderPolicy</code> in-place.\nMutate the current <code>WriterPolicy</code>.\nPush <code>bytes</code> to the end of the buffer, growing it if …\nRead from <code>rdr</code>, returning the number of bytes read or any …\nUnconditionally perform a read into the buffer.\nEnsure room in the buffer for <em>at least</em> <code>additional</code> bytes. …\nReserve space in the buffer for at least <code>additional</code> bytes. …\nEnsure enough space in the buffer for <em>at least</em> <code>additional</code> …\nEnsure space for at least <code>additional</code> more bytes in the …\nSeek to an ofPet, in bytes, in the underlying reader.\nSeek to the ofPet, in bytes, in the underlying writer.\nSet a thread-local handler for errors thrown in <code>BufWriter</code>…\nApply a new <code>ReaderPolicy</code> to this <code>BufReader</code>, returning the …\nSet a new <code>WriterPolicy</code>, returning the transformed type.\nConsume <code>self</code> and return an adapter which implements <code>Read</code> …\nReturn the number of bytes that can be read into this …\nWrap <code>inner</code> with an existing <code>Buffer</code> instance and the …\nCreate a new <code>BufWriter</code> wrapping <code>inner</code>, utilizing the …\nWrap <code>inner</code> with an existing <code>Buffer</code> instance.\nCreate a new <code>BufReader</code> wrapping <code>inner</code>, utilizing a buffer …\nCreate a new <code>BufWriter</code> wrapping <code>inner</code>, utilizing a buffer …\nWrap <code>inner</code> with the given buffer capacity.\nCreate a new buffer with <em>at least</em> the given capacity.\nWrite all bytes in this buffer to <code>wrt</code>, ignoring …\nWrite, at most, the given number of bytes from this buffer …\nWrite bytes from this buffer to <code>wrt</code>. Returns the number of …\nFlag for <code>ReaderPolicy</code> methods to signal whether or not …\nFlag for <code>WriterPolicy</code> methods to tell <code>BufWriter</code> how many …\nFlush the buffer if it contains at least the given number …\nOnly ever flush exactly the given number of bytes, until …\nFlush the buffer if it contains the given byte.\nFlush the buffer if it contains a newline (<code>\\n</code>).\nA policy for <code>BufReader</code> which ensures there is at least the …\nTrait that governs <code>BufReader</code>’s behavior.\nDefault policy for both <code>BufReader</code> and <code>BufWriter</code> that …\nA trait which tells <code>BufWriter</code> when to flush.\nCalled after bytes are consumed from the buffer.\nReturn <code>true</code> if the buffer should be flushed after reading …\nFlushes the given amount if possible, nothing otherwise.\nConsulted before attempting to read into the buffer.\nReturn <code>FlushAmt(n &gt; 0)</code> if the buffer should be flushed …\nFlushes the buffer if there is not enough room to fit …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the number of bytes to ensure are in the buffer.")