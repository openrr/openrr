searchState.loadedDescShard("typewit", 0, "This crate provides abstractions for creating type …\nThe type parameter used for type witnesses.\nproof of <code>L == R</code>\nGets a type witness for <code>Self</code>.\nEmulation of <code>T == U</code> bounds.\nA constant with the type witness\nConstructs this type witness.\nConstructs a <code>TypeEq&lt;T, T&gt;</code>.\nproof of <code>L != R</code>\nProof that <code>Self</code> is the same type as <code>Self::Type</code>, provides …\nThe same type as <code>Self</code>, used to emulate type equality …\nA witness of whether its <code>L</code> and <code>R</code> type parameters are the …\nValue-level proof that <code>L</code> is the same type as <code>R</code>\nValue-level proof that <code>L</code> is a different type to <code>R</code>\nGets the type argument that this type witness witnesses.\nA constant of the type witness\nMarker types for passing constants as type arguments.\nConverts this <code>TypeCmp&lt;L, R&gt;</code> into an <code>Option&lt;TypeEq&lt;L, R&gt;&gt;</code>.\nReturns the contained <code>TypeEq</code>\nReturns the contained <code>TypeNe</code>\nSwaps the type arguments of this <code>TypeCmp</code>\nSwaps the type parameters of this <code>TypeEq</code>\nSwaps the type arguments of this <code>TypeNe</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCombines <code>TypeEq&lt;L, R&gt;</code> and <code>TypeEq&lt;Usize&lt;UL&gt;, Usize&lt;UR&gt;&gt;</code> …\nConverts a <code>TypeCmp&lt;L, R&gt;</code> to <code>TypeCmp&lt;&amp;mut L, &amp;mut R&gt;</code>\nConverts a <code>TypeEq&lt;L, R&gt;</code> to <code>TypeEq&lt;&amp;mut L, &amp;mut R&gt;</code>\nConverts a <code>TypeNe&lt;L, R&gt;</code> to <code>TypeNe&lt;&amp;mut L, &amp;mut R&gt;</code>\nConverts a <code>TypeCmp&lt;L, R&gt;</code> to <code>TypeCmp&lt;&amp;L, &amp;R&gt;</code>\nConverts a <code>TypeEq&lt;L, R&gt;</code> to <code>TypeEq&lt;&amp;L, &amp;R&gt;</code>\nConverts a <code>TypeNe&lt;L, R&gt;</code> to <code>TypeNe&lt;&amp;L, &amp;R&gt;</code>\nDeclares an injective type-level function\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this <code>TypeCmp</code> is a <code>TypeCmp::Eq</code>.\nReturns whether this <code>TypeCmp</code> is a <code>TypeCmp::Ne</code>.\nJoins this <code>TypeEq&lt;L, R&gt;</code> with a <code>TypeEq&lt;R, O&gt;</code>, producing a …\nJoins this <code>TypeCmp&lt;L, R&gt;</code> with a <code>TypeEq&lt;Q, L&gt;</code>, producing a …\nJoins a proof of <code>L != R</code> with a proof of <code>J == L</code>, creating a …\nJoins this <code>TypeCmp&lt;L, R&gt;</code> with a <code>TypeEq&lt;R, Q&gt;</code>, producing a …\nJoins a proof of <code>L != R</code> with a proof of <code>R == J</code>, creating a …\nMaps the type arguments of this <code>TypeCmp</code> by using the <code>F</code> …\nMaps the type arguments of this <code>TypeEq</code> by using the <code>F</code> …\nMaps the type arguments of this <code>TypeNe</code> by using the <code>F</code> …\nMaps the <code>L</code> and <code>R</code> arguments of this <code>TypeNe&lt;L, R&gt;</code> back to …\nConverts this <code>TypeCmp&lt;L, R&gt;</code> into an <code>Option&lt;TypeNe&lt;L, R&gt;&gt;</code>.\nConstructs a <code>TypeEq&lt;T, T&gt;</code>.\nConstructs a <code>TypeEq&lt;L, R&gt;</code>.\nConstructs a <code>TypeNe&lt;L, R&gt;</code>.\nMatch which expands top-level <code>|</code> patterns to multiple match …\nMaps the type arguments of this <code>TypeCmp</code> by using the <code>F</code> …\nMaps the type arguments of this <code>TypeEq</code> by using the <code>F</code> …\nMaps the type arguments of this <code>TypeNe</code> by using the <code>F</code> …\nMaps the <code>L</code> and <code>R</code> arguments of this <code>TypeNe&lt;L, R&gt;</code> back to …\nHints to the compiler that a <code>TypeEq&lt;L, R&gt;</code> can only be …\nDeclares a type witness enum.\nConverts this <code>TypeEq</code> into a <code>TypeCmp</code>\nConverts this <code>TypeNe</code> into a <code>TypeCmp</code>\nA no-op cast from <code>R</code> to <code>L</code>.\nA no-op cast from <code>L</code> to <code>R</code>.\nConstructs a <code>TypeEq&lt;T, T&gt;</code>\nType-level functions.\nDeclares a type-level function (struct that implements …\n<code>TypeNe</code>-related items\nConstructs a <code>TypeNe</code> of types that are statically known to …\nMaps the type arguments of this <code>TypeCmp</code> by using the …\nMaps the type arguments of this <code>TypeEq</code> by using the …\nMaps the type arguments of this <code>TypeNe</code> by using the …\nMaps the type arguments of this <code>TypeCmp</code> by using the …\nMaps the type arguments of this <code>TypeEq</code> by using the …\nMaps the type arguments of this <code>TypeNe</code> by using the …\nReturns the contained <code>TypeEq</code>\nReturns the contained <code>TypeNe</code>\nConstructs a <code>TypeCmp&lt;L, R&gt;</code> by comparing the <code>L</code> and <code>R</code> types …\nConstructs <code>TypeEq&lt;L, R&gt;</code> if <code>L == R</code>, otherwise returns None.\nConstructs <code>TypeNe&lt;L, R&gt;</code> if <code>L != R</code>, otherwise returns None.\nConstructs a <code>TypeNe</code> by mapping from a <code>TypeNe&lt;</code><code>LeftArg</code><code>, </code>…\nCombines this <code>TypeEq&lt;L0, R0&gt;</code> with a <code>TypeEq&lt;L1, R1&gt;</code>, …\nCombines three <code>TypeEq&lt;L*, R*&gt;</code> to produce a …\nCombines four <code>TypeEq&lt;L*, R*&gt;</code> to produce a …\nMarker type for passing <code>const VAL: bool</code> as a type …\nType Witness that <code>Bool&lt;B&gt;</code> is either <code>Bool&lt;true&gt;</code> or …\nType witness that <code>B</code> is either <code>Bool</code><code>&lt;true&gt;</code> or <code>Bool</code><code>&lt;false&gt;</code>\nMarker type for passing <code>const VAL: char</code> as a type …\nA type that represents a constant\nTrait alias for <code>ConstMarker&lt;Of = Of&gt;</code>\nWitnesses that <code>B == false</code>\nWitnesses that <code>B == false</code>\nMarker type for passing <code>const VAL: i128</code> as a type …\nMarker type for passing <code>const VAL: i16</code> as a type parameter.\nMarker type for passing <code>const VAL: i32</code> as a type parameter.\nMarker type for passing <code>const VAL: i64</code> as a type parameter.\nMarker type for passing <code>const VAL: i8</code> as a type parameter.\nMarker type for passing <code>const VAL: isize</code> as a type …\nThe type of this constant\nWitnesses that <code>B == true</code>\nWitnesses that <code>B == true</code>\nMarker type for passing <code>const VAL: u128</code> as a type …\nMarker type for passing <code>const VAL: u16</code> as a type parameter.\nMarker type for passing <code>const VAL: u32</code> as a type parameter.\nMarker type for passing <code>const VAL: u64</code> as a type parameter.\nMarker type for passing <code>const VAL: u8</code> as a type parameter.\nMarker type for passing <code>const VAL: usize</code> as a type …\nThe value of this constant\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nCompares <code>self</code> and <code>other</code> for equality.\nGets a proof of <code>B == Bool&lt;false&gt;</code>.\nGets a proof of <code>B == Bool&lt;true&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether <code>B == Bool&lt;false&gt;</code>\nWhether <code>B == Bool&lt;true&gt;</code>\nGets a proof of <code>B == Bool&lt;false&gt;</code>, returns None if …\nGets a proof of <code>B == Bool&lt;true&gt;</code>, returns None if …\nGets a proof of <code>B == Bool&lt;false&gt;</code>.\nGets a proof of <code>B == Bool&lt;true&gt;</code>.\nThe argument to this function with <code>Ret</code> as the return value.\nCalls the <code>F</code> type-level function with <code>T</code> as its argument.\n<code>CallFn</code> with an additional <code>F:</code><code>InjTypeFn&lt;A&gt;</code> requirement, …\nType-level identity function\nReverses an <code>InjTypeFn</code>, its arguments become return values, …\nType-level function from <code>T</code> to <code>&amp;&#39;a T</code>\nType-level function from <code>T</code> to <code>&amp;&#39;a mut T</code>\nAn  injective  type-level function\nType-level function which implements <code>TypeFn</code> by delegating …\nConstructs a <code>FnRev</code>.\nMake a value of this type-level function\nMake a value of this type-level function\nConstructs an <code>Invoke</code>\nThe return value of the function\nReturn value of the function\nThe inverse of <code>TypeFn</code>, for getting the argument of a <code>TypeFn</code>\nHelper constant for adding asserts in the <code>TypeFn</code> impl;\nA function that operates purely on the level of types.\nQueries the argument to a <code>F: </code><code>TypeFn</code> from its return value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a <code>FnRev</code> from <code>&amp;F</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarker type, for constructing <code>TypeNe</code> in <code>TypeNe::with_fn</code> …\nMarker type, for constructing <code>TypeNe</code> in <code>TypeNe::with_fn</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")