searchState.loadedDescShard("immutable_chunkmap", 0, "Immutable maps and sets. See map and set modules for …\nThis Map uses a similar strategy to BTreeMap to ensure …\nMap using a larger chunk size, faster to search, slower to …\nMap using the default chunk size, a good balance of update …\nMap using a smaller chunk size, faster to update, slower …\nA weak reference to a map.\nProduce a map containing the second map subtracted from the\nCreate a weak reference to this map\nReturns the argument unchanged.\nReturns the argument unchanged.\nlookup the mapping for k. If it doesn’t exist return …\nlookup the mapping for k. Return both the key and the …\nlookup the mapping for k. Return the key. If it doesn’t …\nGet a mutable reference to the value mapped to <code>k</code> using …\nSame as <code>get_mut_cow</code> except if the value isn’t in the map …\nSame as <code>get_mut_cow</code> except if the value is not in the map …\nreturn a new map with (k, v) inserted into it. If k …\ninsert in place using copy on write semantics if self is …\nThis will insert many elements at once, and is potentially …\nProduce a map containing the mapping over F of the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nreturn a mutable iterator over the entire map. The iterator\nget the number of elements in the map O(1) time and space\nCreate a new empty map\nreturn an iterator over the subset of elements in the map …\nreturn a mutable iterator over the subset of elements in …\nreturn a new map with the mapping under k removed. If the …\nremove in place using copy on write semantics if self is …\nThis will remove many elements at once, and is potentially …\nReturn the number of strong references to this map (see …\nMerge two maps together. Bindings that exist in both maps …\nreturn a new map with the binding for q, which can be any …\nPerform a copy on write update to the map. In the case that\nThis method updates multiple bindings in one call. Given an\nReturn the number of weak references to this map (see Arc)\nThis set uses a similar strategy to BTreeSet to ensure …\nset with a larger chunk size, faster to search, slower to …\nset with the default chunk size, a good balance of search …\nset with a smaller chunk size, faster to update, slower to …\nreturn true if the set contains k, else false. Runs in …\nReturn the difference of two sets. Runs in O(log(N) + M) …\nCreate a weak reference to this set\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nreturn a reference to the item in the set that is equal to …\nreturn a new set with k inserted into it. If k already …\ninsert <code>k</code> with copy on write semantics. if <code>self</code> is a unique …\nThis will insert many elements at once, and is potentially …\nreturn the intersection of 2 sets. Runs in O(log(N) + M) …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nget the number of elements in the map O(1) time and space\nCreate a new empty set\nreturn an iterator over the subset of elements in the set …\nreturn a new set with k removed. Runs in log(N) time and …\nremove <code>k</code> from the set in place with copy on write semantics\nRemove multiple elements in a single pass. Similar …\nReturn the number of strong references to this set (see …\nreturn the union of 2 sets. Runs in O(log(N) + M) time and …\nThis is just slightly wierd, however if you have a bunch of\nReturn the number of weak references to this set (see Arc)")