searchState.loadedDescShard("petgraph", 0, "<code>petgraph</code> is a graph data structure library.\nMarker type for a directed graph.\nEdge direction.\nA graph’s edge type determines whether it has directed …\nAn <code>Incoming</code> edge is an inbound edge <em>to</em> the current node.\nConvert an element like <code>(i, j)</code> or <code>(i, j, w)</code> into a triple …\nAn <code>Outgoing</code> edge is an outward edge <em>from</em> the current node.\nMarker type for an undirected graph.\nSimple adjacency list.\nGraph algorithms.\nCompressed Sparse Row (CSR) is a sparse adjacency matrix …\nGraph traits for associated data and graph construction.\nSimple graphviz dot file format output.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>Graph&lt;N, E, Ty, Ix&gt;</code> is a graph datastructure using an …\n<code>GraphMap&lt;N, E, Ty&gt;</code> is a graph datastructure where node …\nReturn <code>0</code> for <code>Outgoing</code> and <code>1</code> for <code>Incoming</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>MatrixGraph&lt;N, E, Ty, NullN, NullE, Ix&gt;</code> is a graph …\nOperators for creating new graphs from existings ones.\nReturn the opposite <code>Direction</code>.\nCommonly used items.\n<code>StableGraph</code> keeps indices stable across removals.\n<code>UnionFind&lt;K&gt;</code> is a disjoint-set data structure.\nGraph traits and graph traversals.\nAdjacency list edge index type, a pair of integers.\nA reference to an edge of the graph.\nAn iterator over the <code>EdgeReference</code> of all the edges of the …\nAn adjacency list with labeled edges.\nAn iterator over the indices of the neighbors of a node.\nAdjacency list node index type, a plain integer.\nAn iterator over all node indices in the graph.\nAn Iterator over the indices of the outgoing edges from a …\nIterator over the <code>EdgeReference</code> of the outgoing edges from …\nA very simple adjacency list with no node or label weights.\nAdd an edge from <code>a</code> to <code>b</code> to the graph, with its associated …\nAdd an edge from <code>a</code> to <code>b</code> to the graph, with its associated …\nAdds a new node to the list. This allocates a new <code>Vec</code> and …\nAdds a new node to the list. This allocates a new <code>Vec</code> and …\nAdds a new node to the list by giving its list of …\nAdds a new node to the list. This allocates a new <code>Vec</code> and …\nRemoves all nodes and edges from the list.\nLookups whether there is an edge from <code>a</code> to <code>b</code>.\nReturns the number of edges in the list\nReturns the number of edges in the list\nAccesses the source and target of edge <code>e</code>\nReturns an iterator over all edge indices of the graph.\nAccesses the weight of edge <code>e</code>\nAccesses the weight of edge <code>e</code>\nLookups whether there is an edge from <code>a</code> to <code>b</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator of all nodes with an edge starting …\nCreates a new, empty adjacency list.\nReturns the number of nodes in the list\nReturns an iterator over all node indices of the graph.\nUpdates or adds an edge from <code>a</code> to <code>b</code> to the graph, with its …\nCreates a new, empty adjacency list tailored for <code>nodes</code> …\nAn algorithm error: a cycle was found in the graph.\nWorkspace for a graph traversal.\nA floating-point measure.\nAssociated data that can be used for measures (such as …\nAn algorithm error: a cycle of negative weights was found …\nSome measure of positive numbers, assuming positive …\nA reusable state for computing the <em>strongly connected </em>…\nA floating-point measure that can be computed from <code>usize</code> …\nBellman-Ford algorithms.\nGraph Condense every strongly connected component into a …\n[Generic] Return the number of connected components of the …\nCompute dominators of a control-flow graph.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n[Generic] Check if there exists a path starting at <code>from</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn <code>true</code> if the graph is bipartite. A graph is …\n[Generic] Return <code>true</code> if the input directed graph contains …\n[Generic] Return <code>true</code> if the input graph contains a cycle.\n[Generic] Compute the <em>strongly connected components</em> using …\nMinimum Spanning Tree algorithms.\nCreates a new <code>TarjanScc</code>\nReturns the index of the component in which v has been …\nReturn a node id that participates in the cycle\n[Generic] Compute the <em>strongly connected components</em> using …\nRenamed to <code>kosaraju_scc</code>.\n[Generic] Compute the <em>strongly connected components</em> using …\n[Generic] Perform a topological sort of a directed graph.\nCompute the transitive reduction and closure of a directed …\n[Generic] A* shortest path algorithm.\n[Generic] Compute shortest paths from node <code>source</code> to all …\n[Generic] Find the path of a negative cycle reachable from …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n[Generic] Dijkstra’s shortest path algorithm.\nIterator for nodes dominated by a given node.\nThe dominance relation for some graph and root.\nIterator for a node’s dominators.\nIterate over all of the given node’s dominators …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the immediate dominator of the given node.\nIterate over all nodes immediately dominated by the given …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the root node used to construct these dominance …\nThis is an implementation of the engineered “Simple, …\nIterate over the given node’s strict dominators.\n[Generic] Finds a feedback arc set: a set of edges in the …\n[Generic] Floyd–Warshall algorithm is an algorithm for …\n[Generic] Ford-Fulkerson algorithm.\n[Generic] Return <code>true</code> if the graphs <code>g0</code> and <code>g1</code> are …\n[Generic] Return <code>true</code> if the graphs <code>g0</code> and <code>g1</code> are …\n[Generic] Return <code>true</code> if <code>g0</code> is isomorphic to a subgraph of …\n[Generic] Return <code>true</code> if <code>g0</code> is isomorphic to a subgraph of …\nUsing the VF2 algorithm, examine both syntactic and …\n[Generic] k’th shortest path algorithm.\nComputed <em>matching</em> of the graph.\nReturns <code>true</code> if given edge is in the matching, or <code>false</code> …\nReturns <code>true</code> if given node is in the matching, or <code>false</code> …\nIterates over all edges from the matching.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n[Generic] Compute a <em>matching</em> using a greedy heuristic.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the number of matched <strong>edges</strong> is 0.\nReturns <code>true</code> if the matching is perfect.\nGets the number of matched <strong>edges</strong>.\nGets the matched counterpart of given node, if there is …\n[Generic] Compute the <em>maximum matching</em> using Gabow’s …\nIterates over all nodes from the matching.\nAn iterator producing a minimum spanning forest of a graph.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n[Generic] Compute a <em>minimum spanning tree</em> of a graph.\n[Generic] Page Rank algorithm.\nReturns an iterator that produces all simple paths from …\nCreates a representation of the same graph respecting …\nComputes the transitive reduction and closure of a DAG.\nCompressed Sparse Row (<code>CSR</code>) is a sparse adjacency matrix …\nCsr edge index type, a plain integer.\nCsr creation error: edges were not in sorted order.\nCsr node index type, a plain integer.\nIterator over all nodes of a graph.\nReturn <code>true</code> if the edge was added\nAdds a new node with the given weight, returning the …\nRemove all edges\nComputes in <strong>O(log |V|)</strong> time.\nReturn an iterator of all edges of <code>a</code>.\nComputes in <strong>O(1)</strong> time.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>Csr</code> from a sorted sequence of edges\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn an iterator of all neighbors of <code>a</code>.\nComputes in <strong>O(1)</strong> time.\nCreate an empty <code>Csr</code>.\nComputes in <strong>O(1)</strong> time.\nAccess the edge’s weight.\nCreate a new <code>Csr</code> with <code>n</code> nodes. <code>N</code> must implement <code>Default</code> …\nA graph that can be extended with further nodes and edges\nA graph that can be created\nAccess node and edge weights (associated data).\nAccess node and edge weights mutably.\nA graph edge.\nA graph element.\nIterator adaptors for iterators of <code>Element</code>.\nAn iterator that filters graph elements.\nCreate a graph from an iterator of elements.\nA graph node.\nAdd a new edge. If parallel edges (duplicate) are not …\nCreate an iterator adaptor that filters graph elements.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdd or update the edge from <code>a</code> to <code>b</code>. Return the id of the …\n<code>Dot</code> configuration.\n<code>Dot</code> implements output to graphviz .dot format for a graph.\nUse indices for edge labels.\nUse no edge labels.\nDo not print the graph/digraph string.\nUse indices for node labels.\nUse no node labels.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>Dot</code> formatting wrapper with default configuration.\nCreate a <code>Dot</code> formatting wrapper with custom configuration.\nThe default integer type for graph indices. <code>u32</code> is the …\nA <code>Graph</code> with directed edges.\nThe graph’s edge type.\nEdge identifier.\nIterator over the edge indices of a graph.\nReference to a <code>Graph</code> edge.\nIterator over all edges of a graph.\nIterator yielding mutable access to all edge weights.\nIterator over the edges of from or to a node\nIterator over the multiple directed edges connecting a …\nAn iterator over either the nodes without edges to them or …\n<code>Frozen</code> is a graph wrapper.\n<code>Graph&lt;N, E, Ty, Ix&gt;</code> is a graph datastructure using an …\nA <code>GraphIndex</code> is a node or edge index.\nTrait for the unsigned integer type used for node and edge …\nIterator over the neighbors of a node.\nThe graph’s node type.\nNode identifier.\nIterator over the node indices of a graph.\nIterator over all nodes of a graph.\nIterator yielding mutable access to all node weights.\nA <code>Graph</code> with undirected edges.\nA “walker” object that can be used to step through the …\nAdd an edge from <code>a</code> to <code>b</code> to the graph, with its associated …\nAdd a node (also called vertex) with associated data <code>weight</code>…\nReturn the current node and edge capacity of the graph.\nRemove all nodes and edges\nRemove all edges\nLookup if there is an edge from <code>a</code> to <code>b</code>.\nReturn a “walker” object that can be used to step …\nReturn the number of edges in the graph.\nAccess the source and target nodes for <code>e</code>.\nShort version of <code>EdgeIndex::new</code>\nReturn an iterator over the edge indices of the graph\nCreate an iterator over all edges, in indexed order.\nAccess the weight for edge <code>e</code>.\nAccess the weight for edge <code>e</code>, mutably.\nReturn an iterator yielding immutable access to all edge …\nReturn an iterator yielding mutable access to all edge …\nReturn an iterator of all edges of <code>a</code>.\nReturn an iterator over all the edges connecting <code>a</code> and <code>b</code>.\nReturn an iterator of all edges of <code>a</code>, in the specified …\nAn invalid <code>EdgeIndex</code> used to denote absence of an edge, …\nExtend the graph from an iterable of edges.\nReturn an iterator over either the nodes without edges to …\nCreate a new <code>Graph</code> by mapping nodes and edges. A node or …\nLookup an edge from <code>a</code> to <code>b</code>.\nLookup an edge between <code>a</code> and <code>b</code>, in either direction.\nAccessor for data structure internals: the first edge in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>Graph</code> from an iterable of edges.\nIndex the <code>Graph</code> by two indices, any combination of node or …\nIndex the <code>Graph</code> by two indices, any combination of node or …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the graph into either undirected or directed. No …\nConvert the graph into a vector of Nodes and a vector of …\nWhether the graph has directed edges or not.\nCreate a new <code>Graph</code> by mapping node and edge weights to new …\nReturn an iterator of all nodes with an edge starting from …\nReturn an iterator of all neighbors that have an edge …\nReturn an iterator of all neighbors that have an edge …\nCreate a new <code>Graph</code> with directed edges.\nCreate a new <code>Frozen</code> from a mutable reference to a graph.\nCreate a new <code>Graph</code> with undirected edges.\nStep to the next edge and its endpoint node in the walk …\nAccessor for data structure internals: the next edge for …\nAccessor for data structure internals: the first edge in …\nAccessor for data structure internals: the next edge for …\nReturn the number of nodes (vertices) in the graph.\nShort version of <code>NodeIndex::new</code>\nReturn an iterator over the node indices of the graph.\nAccess the weight for node <code>a</code>.\nAccess the weight for node <code>a</code>, mutably.\nReturn an iterator yielding immutable access to all node …\nReturn an iterator yielding mutable access to all node …\nAccess the internal edge array.\nAccess the internal node array.\nRemove an edge and return its edge weight, or <code>None</code> if it …\nRemove <code>a</code> from the graph if it exists, and return its …\nReserves capacity for at least <code>additional</code> more edges to be …\nReserves the minimum capacity for exactly <code>additional</code> more …\nReserves the minimum capacity for exactly <code>additional</code> more …\nReserves capacity for at least <code>additional</code> more nodes to be …\nKeep all edges that return <code>true</code> from the <code>visit</code> closure, …\nKeep all nodes that return <code>true</code> from the <code>visit</code> closure, …\nReverse the direction of all edges\nShrinks the capacity of the graph as much as possible.\nShrinks the capacity of the underlying edges collection as …\nShrinks the capacity of the underlying nodes collection as …\nReturn the source node index.\nReturn the target node index.\nAdd or update an edge from <code>a</code> to <code>b</code>. If the edge already …\nAccess the edge’s weight.\nAssociated node data.\nAssociated edge data.\nCreate a new <code>Graph</code> with estimated capacity.\nA <code>GraphMap</code> with directed edges.\n<code>GraphMap&lt;N, E, Ty&gt;</code> is a graph datastructure using an …\nA trait group for <code>GraphMap</code>’s node identifier.\nA reference that is hashed and compared by its pointer …\nA <code>GraphMap</code> with undirected edges.\nAdd an edge connecting <code>a</code> and <code>b</code> to the graph, with …\nAdd node <code>n</code> to the graph.\nReturn an iterator over all edges of the graph with their …\nReturn an iterator over all edges of the graph in …\nReturn the current node and edge capacity of the graph.\nRemove all nodes and edges\nPtr is ordered by pointer value, i.e. an arbitrary but …\nReturn <code>true</code> if the edge connecting <code>a</code> with <code>b</code> is contained …\nReturn <code>true</code> if the node is contained in the graph.\nReturn the number of edges in the graph.\nReturn a reference to the edge weight connecting <code>a</code> with <code>b</code>, …\nReturn a mutable reference to the edge weight connecting <code>a</code> …\nReturn an iterator of target nodes with an edge starting …\nReturn an iterator of target nodes with an edge starting …\nPtr compares by pointer equality, i.e if they point to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>GraphMap</code> from an iterable of edges.\nCreates a <code>GraphMap</code> that corresponds to the given <code>Graph</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn a <code>Graph</code> that corresponds to this <code>GraphMap</code>.\nWhether the graph has directed edges.\nReturn an iterator of all nodes with an edge starting from …\nReturn an iterator of all neighbors that have an edge …\nCreate a new <code>GraphMap</code>\nReturn the number of nodes in the graph.\nReturn an iterator over the nodes of the graph.\nRemove edge from <code>a</code> to <code>b</code> from the graph and return the edge …\nReturn <code>true</code> if node <code>n</code> was removed.\nCreate a new <code>GraphMap</code> with estimated capacity.\nCreate a new <code>GraphMap</code> with estimated capacity, and …\nA <code>MatrixGraph</code> with directed edges.\nIterator over all edges of a graph.\nIterator over the edges of from or to a node\n<code>MatrixGraph&lt;N, E, Ty, Null&gt;</code> is a graph datastructure using …\nIterator over the neighbors of a node.\nIterator over the node identifiers of a graph.\nNode identifier.\nIterator over all nodes of a graph.\n<code>NotZero</code> is used to optimize the memory usage of edge …\nWrapper trait for an <code>Option</code>, allowing user-defined structs …\nA <code>MatrixGraph</code> with undirected edges.\nBase trait for types that can be wrapped in a <code>NotZero</code>.\nAdd an edge from <code>a</code> to <code>b</code> to the graph, with its associated …\nAdd a node (also called vertex) with associated data <code>weight</code>…\nRemove all nodes and edges.\nReturn the number of edges in the graph.\nAccess the weight for edge <code>e</code>.\nAccess the weight for edge <code>e</code>, mutably.\nReturn an iterator of all edges of <code>a</code>.\nReturn an iterator of all edges of <code>a</code>, in the specified …\nExtend the graph from an iterable of edges.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>MatrixGraph</code> from an iterable of edges.\nReturn true if there is an edge between <code>a</code> and <code>b</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn whether the graph has directed edges or not.\nReturn true if <code>self</code> is equal to the sentinel value.\nReturn an iterator of all nodes with an edge starting from …\nReturn an iterator of all neighbors that have an edge …\nCreate a new <code>MatrixGraph</code> with directed edges.\nCreate a new <code>MatrixGraph</code> with undirected edges.\nReturn the number of nodes (vertices) in the graph.\nShort version of <code>NodeIndex::new</code> (with Ix = <code>DefaultIx</code>)\nAccess the weight for node <code>a</code>.\nAccess the weight for node <code>a</code>, mutably.\nRemove the edge from <code>a</code> to <code>b</code> to the graph.\nRemove <code>a</code> from the graph.\nUpdate the edge from <code>a</code> to <code>b</code> to the graph, with its …\nCreate a new <code>MatrixGraph</code> with estimated capacity for nodes.\nReturn the singleton object which can be used as a …\n[Generic] complement of the graph\nIterator over the edge indices of a graph.\nReference to a <code>StableGraph</code> edge.\nIterator over all edges of a graph.\nIterator over the edges of from or to a node\nIterator over the multiple directed edges connecting a …\nAn iterator over either the nodes without edges to them or …\nIterator over the neighbors of a node.\nIterator over the node indices of a graph.\nIterator over all nodes of a graph.\nA <code>StableGraph</code> with directed edges.\n<code>StableGraph&lt;N, E, Ty, Ix&gt;</code> is a graph datastructure using …\nA <code>StableGraph</code> with undirected edges.\nA “walker” object that can be used to step through the …\nAdd an edge from <code>a</code> to <code>b</code> to the graph, with its associated …\nAdd a node (also called vertex) with associated data <code>weight</code>…\nReturn the current node and edge capacity of the graph.\nRemove all nodes and edges\nRemove all edges\nLookup if there is an edge from <code>a</code> to <code>b</code>.\nReturn a “walker” object that can be used to step …\nReturn the number of edges in the graph.\nAccess the source and target nodes for <code>e</code>.\nReturn an iterator over the edge indices of the graph\nCreate an iterator over all edges in the graph, in indexed …\nAccess the weight for edge <code>e</code>.\nAccess the weight for edge <code>e</code>, mutably\nReturn an iterator yielding immutable access to all edge …\nReturn an iterator yielding mutable access to all edge …\nReturn an iterator of all edges of <code>a</code>.\nReturn an iterator over all the edges connecting <code>a</code> and <code>b</code>.\nReturn an iterator of all edges of <code>a</code>, in the specified …\nExtend the graph from an iterable of edges.\nReturn an iterator over either the nodes without edges to …\nCreate a new <code>StableGraph</code> by mapping nodes and edges. A …\nLookup an edge from <code>a</code> to <code>b</code>.\nLookup an edge between <code>a</code> and <code>b</code>, in either direction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>StableGraph</code> from an iterable of edges.\nIndex the <code>StableGraph</code> by two indices, any combination of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the graph has directed edges or not.\nCreate a new <code>StableGraph</code> by mapping node and edge weights …\nReturn an iterator of all nodes with an edge starting from …\nReturn an iterator of all neighbors that have an edge …\nReturn an iterator of all neighbors that have an edge …\nCreate a new <code>StableGraph</code> with directed edges.\nStep to the next edge and its endpoint node in the walk …\nReturn an upper bound of the node indices in the graph\nReturn the number of nodes (vertices) in the graph.\nReturn an iterator over the node indices of the graph\nAccess the weight for node <code>a</code>.\nAccess the weight for node <code>a</code>, mutably.\nReturn an iterator yielding immutable access to all node …\nReturn an iterator yielding mutable access to all node …\nRemove an edge and return its edge weight, or <code>None</code> if it …\nRemove <code>a</code> from the graph if it exists, and return its …\nKeep all edges that return <code>true</code> from the <code>visit</code> closure, …\nKeep all nodes that return <code>true</code> from the <code>visit</code> closure, …\nReverse the direction of all edges\nAdd or update an edge from <code>a</code> to <code>b</code>. If the edge already …\nAccess the edge’s weight.\nCreate a new <code>StableGraph</code> with estimated capacity.\n<code>UnionFind&lt;K&gt;</code> is a disjoint-set data structure. It tracks …\nReturns <code>true</code> if the given elements belong to the same set, …\nReturn the representative for <code>x</code>.\nReturn the representative for <code>x</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn a vector mapping each element to its representative.\nCreate a new <code>UnionFind</code> of <code>n</code> disjoint sets.\nUnify the two sets containing <code>x</code> and <code>y</code>.\nThe associated adjacency matrix type\nAn edge to an already visited node.\nA breadth first search (BFS) of a graph.\nStop the DFS traversal and return the provided value.\nContinue the DFS traversal as normal.\nControl flow for <code>depth_first_search</code> callbacks.\nControl flow for callbacks.\nA cross or forward edge.\nDefine associated data for nodes and edges\nVisit nodes of a graph in a depth-first-search (DFS) …\nA depth first search (DFS) visitor event.\nVisit nodes in a depth-first-search (DFS) emitting nodes …\nA graph with a known edge count.\nAn edge-filtering graph adaptor.\nA filtered edges iterator.\nA filtered neighbors iterator.\nA filtered neighbors-directed iterator.\nedge identifier\nThe graph’s <code>NodeId</code>s map to indices\nAn edge reference.\nThe kind of edges in the graph.\nA graph filter for edges\nA graph filter for nodes.\nAll edges from a node have been reported.\nCreate or access the adjacency matrix of a graph.\nBase graph trait: defines the associated node identifier …\nEdge kind property (directed or undirected edges)\nA copyable reference to a graph.\nAccess to the sequence of the graph’s edges\nAccess to the edges of each node.\nAccess to all edges of each node, in the specified …\nAccess to the neighbors of each node\nAccess to the neighbors of each node, through incoming or …\nAccess to the sequence of the graph’s <code>NodeId</code>s.\nAccess to the sequence of the graph’s nodes\nThe associated map type\nThe graph’s <code>NodeId</code>s map to indices, in a range without …\nA graph with a known node count.\nA node-filtering graph adaptor.\nA filtered edges iterator.\nA filtered edges iterator.\nA filtered neighbors iterator.\nA filtered node references iterator.\nnode identifier\nThe graph’s <code>NodeId</code>s map to indices\nA node reference.\nPrune the current node from the DFS traversal. No more …\nAn edge-reversing graph adaptor.\nA reversed edge reference\nA reversed edge references iterator.\nA reversed edges iterator.\nStrictly monotonically increasing event time for a depth …\nA topological order traversal for a graph.\nAn edge of the tree formed by the traversal.\nA mapping for storing the visited status for NodeId <code>N</code>.\nA graph that can create a map that tracks the visited …\nA walker is a traversal state, but where part of the …\nA walker and its context wrapped into an iterator.\nCreate the adjacency matrix\nReturn the original, unreversed edge reference.\nGet the value in <code>Control::Break(_)</code>, if present.\nA recursive depth first search.\nThe map of discovered nodes\nThe map of discovered nodes\nThe map of discovered nodes\nReturn an upper bound of the edge indices in the graph …\nReturn the number of edges in the graph.\nCreate a new <strong>Dfs</strong> using the graph’s visitor map, and no …\nCreate a new <code>DfsPostOrder</code> using the graph’s visitor map, …\nThe map of finished nodes\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an <code>NodeFiltered</code> adaptor from the closure <code>filter</code>.\nCreate an <code>EdgeFiltered</code> adaptor from the closure <code>filter</code>.\nConvert <code>i</code> to a node index. <code>i</code> must be a valid value in the …\nConvert <code>i</code> to an edge index. <code>i</code> must be a valid value in the …\nCreate a <code>Dfs</code> from a vector and a visit map\nThe edge’s identifier.\nReturn true to have the edge be part of the graph\nReturn true to have the node be part of the graph\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume <code>self</code> and return the original, unreversed edge …\nReturn true if there is an edge from <code>a</code> to <code>b</code>, false …\nReturn whether <code>a</code> has been visited before.\nCreate an iterator out of the walker and given <code>context</code>.\nCreate an iterator out of the walker and given <code>context</code>.\nKeep the discovered map, but clear the visit stack and …\nKeep the discovered and finished map, but clear the visit …\nReturn an iterator of the neighbors of node <code>a</code>.\nCreate a new <strong>Dfs</strong>, using the graph’s visitor map, and put …\nCreate a new <code>DfsPostOrder</code> using the graph’s visitor map, …\nCreate a new <strong>Bfs</strong>, using the graph’s visitor map, and put …\nCreate a new <code>Topo</code>, using the graph’s visitor map, and …\nReturn the next node in the dfs, or <strong>None</strong> if the traversal …\nReturn the next node in the traversal, or <code>None</code> if the …\nReturn the next node in the bfs, or <strong>None</strong> if the traversal …\nReturn the next node in the current topological order …\nReturn an upper bound of the node indices in the graph …\nClear the visit state\nClear the visit state\nClear visited state, and put all initial nodes in the to …\nReset the visitor map (and resize to new size of graph if …\nThe source node of the edge.\nThe stack of nodes to visit\nThe stack of nodes to visit\nThe queue of nodes to visit\nThe target node of the edge.\nConvert <code>a</code> to an integer index.\nConvert <code>a</code> to an integer index.\nMark <code>a</code> as visited.\nCreate a new visitor map\nAdvance to the next item\nA reference to the weight of the edge.\nCreate a new <code>Topo</code> with initial nodes.")