searchState.loadedDescShard("gilrs", 0, "GilRs - Game Input Library for Rust\nBattery is charged.\nBattery is charging.\nIterator over all connected gamepads.\nDevice is running on the battery.\nGamepad does not use any mappings but driver should …\nSame gamepad element is referenced by axis and button.\nError type which can be returned when creating <code>Gilrs</code>.\nRepresents handle to game controller.\nGamepad ID.\nMain object responsible of managing gamepads.\nAllow to create <code>Gilrs </code> with customized behaviour.\nEither <code>pressed ≤ released</code> or one of values is outside […\nGamepad does not have element referenced by <code>EvCode</code>.\nName contains comma (‘,’).\nStores data used to map gamepad buttons and axes.\nThe error type for functions related to gamepad mapping.\nSource of gamepad mappings.\nGamepad does not use any mappings and most gamepad events …\nGamepad is not connected.\nGilrs does not support current platform, but you can use …\nThis function is not implemented for current platform.\n<code>Mapping</code> have button or axis that are not present in SDL2.\nPlatform specific error.\nState of device’s power supply.\nGamepad uses SDL mappings.\nFailed to determine power status.\n<code>Mapping</code> with <code>Button::Unknown</code> or <code>Axis::Unknown</code>.\nDevice doesn’t have battery.\nIf true, will add SDL mappings from …\nIf true, will add SDL mappings included from …\nAdds SDL mappings.\nReturns <code>EvCode</code> associated with axis index.\nReturns <code>Code</code> associated with <code>axis</code>.\nReturns axis state and when it changed.\nReturns <code>AxisOrBtn</code> mapped to <code>Code</code>.\nCreates <code>Gilrs</code>.\nReturns <code>EvCode</code> associated with button index.\nReturns <code>Code</code> associated with <code>btn</code>.\nReturns button state and when it changed.\nReturns a reference to connected gamepad or <code>None</code>.\nReturns counter. Counter data is stored with state and can …\nReturns area in which axis events should be ignored.\nGamepad state and other event related functionality.\nForce feedback module.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns handle to gamepad with given ID. Unlike …\nReturns iterator over all connected gamepads and their ids.\nReturns ID of gamepad.\nIncreases internal counter by one. Counter data is stored …\nInserts new axis mapping.\nInserts new button mapping.\nAdds <code>ev</code> at the end of internal event queue. It can later …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if gamepad is connected.\nReturns true if force feedback is supported by device.\nExamines cached gamepad state to check if given button is …\nif <code>mapping_source()</code> is <code>SdlMappings</code> returns the name of the …\nReturns source of gamepad mapping. Can be used to filter …\nReturns the mapping name if it exists otherwise returns …\nCreate builder with default settings. Use <code>build()</code> to …\nCreates new <code>Gilrs</code> with default settings. See <code>GilrsBuilder</code> …\nCreates new <code>Mapping</code>.\nReturns next pending event. If there is no pending event, …\nSame as Gilrs::next_event, but blocks the thread it is run …\nReturns the name of the gamepad supplied by the OS.\nReturns device’s power supply state. See <code>PowerInfo</code> for …\nReturns the product ID, as assigned by the vendor, when …\nRemoves axis and returns associated <code>NativEvCode</code>.\nRemoves button and returns associated <code>NativEvCode</code>.\nSets counter to 0.\nSets values on which <code>ButtonPressed</code> and <code>ButtonReleased</code> …\nChange gamepad position used by force feedback effects.\nSets gamepad’s mapping and returns SDL2 representation …\nSimilar to <code>set_mapping()</code> but returned string should be …\nDisable or enable automatic state updates. You should use …\nReturns cached gamepad state.\nUpdates internal state according to <code>event</code>.\nReturns gamepad’s UUID.\nExamines cached gamepad state to check axis’s value. …\nReturns the vendor ID, as assigned by the USB-IF, when …\nIf <code>true</code>, use <code>axis_dpad_to_button</code>, <code>Jitter</code> and <code>deadzone</code> …\nGamepad’s elements which state can be represented by …\nValue of axis has changed. Value can be in range [-1.0, 1.0…\nRepresents <code>Axis</code> or <code>Button</code>.\nGamepad’s elements which state can be represented by …\nValue of button has changed. Value can be in range [0.0, …\nSome button on gamepad has been pressed.\nPreviously pressed button has been released.\nThis event can be generated by <code>ev::Repeat</code> event filter.\nPlatform specific event code.\nGamepad has been connected. If gamepad’s UUID doesn’t …\nGamepad has been disconnected. Disconnected gamepad will …\nThere was an <code>Event</code>, but it was dropped by one of filters. …\nHolds information about gamepad event.\nGamepad event.\nA force feedback effect has ran for its duration and …\nReturns <code>Event</code> with <code>EventType::Dropped</code>.\nEvent’s data.\nAlter events in various ways.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nId of gamepad.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if event is <code>Dropped</code> and should be ignored.\nReturns true if axis is <code>LeftStickX</code>, <code>LeftStickY</code>, <code>RightStickX</code>…\nCreates new event with current time.\nReturns the other axis from same element of gamepad, if …\nTime when event was emitted.\nAllow filtering events.\nActual filter implementation.\nDiscard axis events that changed less than <code>threshold</code>.\nRepeats pressed keys.\nMaps axis dpad events to button dpad events.\nDrops events in dead zone and remaps value to keep it in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates new <code>Repeat</code> filter with threshold set to 0.01.\nCreates new <code>Repeat</code> filter with <code>after</code> set to 500ms and <code>every</code>…\nInformation about axis stored in <code>State</code>.\nIterator over <code>AxisData</code>.\nInformation about button stored in <code>State</code>.\nIterator over <code>ButtonData</code>.\nCached gamepad state.\nIterate over axes data.\nReturns axis state and when it changed.\nReturns button state and when it changed.\nIterate over buttons data.\nReturns value of counter when button state last changed.\nReturns value of counter when axis value last changed.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if given button is pressed. Returns <code>false</code> if …\nReturns <code>true</code> if button is pressed.\nReturns <code>true</code> if button is repeating.\nReturns when button state last changed.\nReturns when axis value last changed.\nReturns value of <code>el</code> or 0.0 when there is no information …\nReturns value of button.\nReturns value of axis.\nBasic building block used to create more complex force …\nKind of <code>BaseEffect</code>.\nDevice is not connected\nSpecifies how distance between effect source and listener …\nError that can be returned when passing <code>DistanceModel</code> with …\nHandle to force feedback effect.\nCreates new <code>Effect</code>.\nEnvelope shaped attenuation(time) function.\nBasic error type in force feedback module.\nExponential distance model.\nExponential distance clamped model.\nForce feedback is not supported by device with this ID\nPlay effect for specified time.\nPlay effect until stop() is called.\nDistance model is invalid.\nMax distance is &lt; 0.\nPossible divide by zero\nReference distance is &lt; 0.\nRolloff factor is &lt; 0.\nInverse distance model.\nInverse distance clamped model.\nLinear distance model.\nLinear distance clamped model.\nEffect is not attenuated by distance.\nUnexpected error has occurred\nDescribes how long effect should be played.\nDefines scheduling of the basic force feedback effect.\nThe other end of channel was dropped.\nRepresents duration.\nAdds new <code>BaseEffect</code>.\nAdds gamepad to the list of gamepads associated with …\nAdds gamepad to the list of gamepads associated with …\nStart playback <code>after</code> ticks after <code>Effect::play()</code> is called.\nChanges distance model associated with effect.\nReturns duration of effect calculated as …\nBasic attenuation function.\nValidates all parameters and creates new effect.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nChanges gain of the effect. <code>gain</code> will be clamped to [0.0, …\nChanges gamepads that are associated with effect. Effect …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nType of base effect.\nCreates new builder with following defaults: no gamepads, …\nPlays effect on all associated gamepads.\nPlayback duration.\nChanges position of the source of effect.\nChanges what should happen to effect when it ends.\nDefines playback duration and delays between each …\nChanges distance model associated with effect.\nChanges gain of the effect. <code>gain</code> will be clamped to [0.0, …\nChanges gamepads that are associated with effect. Effect …\nChanges position of the source of effect.\nChanges what should happen to effect when it ends.\nIf playback should be repeated delay it for <code>with_delay</code> …")