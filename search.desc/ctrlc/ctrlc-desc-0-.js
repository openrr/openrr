searchState.loadedDescShard("ctrlc", 0, "Cross platform handling of Ctrl-C signals.\nCtrl-C\nCtrl-C error.\nCtrl-C signal handler already registered.\nSignal could not be found from the system.\nOther signal/event using platform-specific data\nAbort\nAlarm clock\nBus error\nTo parent on child stop or exit\nContinue a stopped process\nFloating point exception\nHangup\nIllegal instruction (not reset when caught)\nInterrupt\nInput/output possible signal\nKill (cannot be caught or ignored)\nWrite on a pipe with no one to read it\nProfiling time alarm\nPower failure imminent.\nQuit\nSegmentation violation\nStack fault (obsolete)\nSendable stop signal not from tty\nBad system call\nSoftware termination signal from kill\nTrace trap (not reset when caught)\nStop signal from tty\nTo readers pgrp upon background tty read\nLike TTIN if (tp-&gt;t_local&amp;LTOSTOP)\nUrgent condition on IO channel\nUser defined signal 1\nUser defined signal 2\nVirtual time alarm\nWindow size changes\nExceeded CPU time limit\nExceeded file size limit\nPlatform specific signal type\nA cross-platform way to represent Ctrl-C or program …\nUnexpected system error.\nProgram termination Maps to <code>SIGTERM</code> and <code>SIGHUP</code> on *nix, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRegister signal handler for Ctrl-C.\nThe same as ctrlc::set_handler but errors if a handler …")