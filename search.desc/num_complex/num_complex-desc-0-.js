searchState.loadedDescShard("num_complex", 0, "Complex numbers.\nA complex number in Cartesian form.\nAlias for a <code>Complex&lt;f32&gt;</code>\nAlias for a <code>Complex&lt;f64&gt;</code>\nA constant <code>Complex</code> <em>i</em>, the imaginary unit.\nA constant <code>Complex</code> 1.\nA constant <code>Complex</code> 0.\nCreate a new <code>Complex&lt;f32&gt;</code> with arguments that can convert …\nCreate a new <code>Complex&lt;f64&gt;</code> with arguments that can convert …\nReturns the complex conjugate. i.e. <code>re - i im</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses <code>a +/- bi</code>; <code>ai +/- b</code>; <code>a</code>; or <code>bi</code> where <code>a</code> and <code>b</code> are of …\nParses <code>a +/- bi</code>; <code>ai +/- b</code>; <code>a</code>; or <code>bi</code> where <code>a</code> and <code>b</code> are of …\nReturns the imaginary unit.\nImaginary portion of the complex number\nImaginary portion of the complex number\nImaginary portion of the complex number\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>1/self</code>\nChecks if the given complex number is finite\nChecks if the given complex number is infinite\nChecks if the given complex number is NaN\nChecks if the given complex number is normal\nReturns the L1 norm <code>|re| + |im|</code> – the Manhattan distance …\nCreate a new <code>Complex</code>\nReturns the square of the norm (since <code>T</code> doesn’t …\nRaises <code>self</code> to a signed integer power.\nRaises <code>self</code> to an unsigned integer power.\nReal portion of the complex number\nReal portion of the complex number\nReal portion of the complex number\nMultiplies <code>self</code> by the scalar <code>t</code>.\nDivides <code>self</code> by the scalar <code>t</code>.")