// This file is @generated by openrr-internal-codegen.
// It is not intended for manual editing.

#![allow(unused_variables)]
#![allow(clippy::useless_conversion, clippy::unit_arg)]

use arci::{BaseVelocity, Error, Isometry2, Isometry3, Scan2D, WaitFuture};
use super::*;
#[derive(Debug, Clone)]
pub struct RemoteGamepadSender {
    pub(crate) client: pb::gamepad_client::GamepadClient<tonic::transport::Channel>,
}
impl RemoteGamepadSender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::gamepad_client::GamepadClient::connect(dst)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::gamepad_client::GamepadClient::new(channel),
        }
    }
}
#[derive(Debug)]
pub struct RemoteGamepadReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteGamepadReceiver<T>
where
    T: arci::Gamepad + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(self) -> pb::gamepad_server::GamepadServer<Self> {
        pb::gamepad_server::GamepadServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
#[derive(Debug, Clone)]
pub struct RemoteJointTrajectoryClientSender {
    pub(crate) client: pb::joint_trajectory_client_client::JointTrajectoryClientClient<
        tonic::transport::Channel,
    >,
}
impl RemoteJointTrajectoryClientSender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::joint_trajectory_client_client::JointTrajectoryClientClient::connect(
                dst,
            )
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::joint_trajectory_client_client::JointTrajectoryClientClient::new(
                channel,
            ),
        }
    }
}
#[derive(Debug)]
pub struct RemoteJointTrajectoryClientReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteJointTrajectoryClientReceiver<T>
where
    T: arci::JointTrajectoryClient + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(
        self,
    ) -> pb::joint_trajectory_client_server::JointTrajectoryClientServer<Self> {
        pb::joint_trajectory_client_server::JointTrajectoryClientServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
#[derive(Debug, Clone)]
pub struct RemoteLaserScan2DSender {
    pub(crate) client: pb::laser_scan2_d_client::LaserScan2DClient<
        tonic::transport::Channel,
    >,
}
impl RemoteLaserScan2DSender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::laser_scan2_d_client::LaserScan2DClient::connect(dst)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::laser_scan2_d_client::LaserScan2DClient::new(channel),
        }
    }
}
#[derive(Debug)]
pub struct RemoteLaserScan2DReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteLaserScan2DReceiver<T>
where
    T: arci::LaserScan2D + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(self) -> pb::laser_scan2_d_server::LaserScan2DServer<Self> {
        pb::laser_scan2_d_server::LaserScan2DServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
impl arci::LaserScan2D for RemoteLaserScan2DSender {
    fn current_scan(&self) -> Result<Scan2D, Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(());
        Ok(
            block_in_place(client.current_scan(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
}
#[tonic::async_trait]
impl<T> pb::laser_scan2_d_server::LaserScan2D for RemoteLaserScan2DReceiver<T>
where
    T: arci::LaserScan2D + 'static,
{
    async fn current_scan(
        &self,
        request: tonic::Request<()>,
    ) -> std::result::Result<tonic::Response<pb::Scan2D>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::LaserScan2D::current_scan(&self.inner)
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
}
#[derive(Debug, Clone)]
pub struct RemoteLocalizationSender {
    pub(crate) client: pb::localization_client::LocalizationClient<
        tonic::transport::Channel,
    >,
}
impl RemoteLocalizationSender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::localization_client::LocalizationClient::connect(dst)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::localization_client::LocalizationClient::new(channel),
        }
    }
}
#[derive(Debug)]
pub struct RemoteLocalizationReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteLocalizationReceiver<T>
where
    T: arci::Localization + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(self) -> pb::localization_server::LocalizationServer<Self> {
        pb::localization_server::LocalizationServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
impl arci::Localization for RemoteLocalizationSender {
    fn current_pose(&self, frame_id: &str) -> Result<Isometry2<f64>, Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(frame_id.into());
        Ok(
            block_in_place(client.current_pose(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
}
#[tonic::async_trait]
impl<T> pb::localization_server::Localization for RemoteLocalizationReceiver<T>
where
    T: arci::Localization + 'static,
{
    async fn current_pose(
        &self,
        request: tonic::Request<::prost::alloc::string::String>,
    ) -> std::result::Result<tonic::Response<pb::Isometry2>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::Localization::current_pose(&self.inner, &request)
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
}
#[derive(Debug, Clone)]
pub struct RemoteMotorDrivePositionSender {
    pub(crate) client: pb::motor_drive_position_client::MotorDrivePositionClient<
        tonic::transport::Channel,
    >,
}
impl RemoteMotorDrivePositionSender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::motor_drive_position_client::MotorDrivePositionClient::connect(
                dst,
            )
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::motor_drive_position_client::MotorDrivePositionClient::new(
                channel,
            ),
        }
    }
}
#[derive(Debug)]
pub struct RemoteMotorDrivePositionReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteMotorDrivePositionReceiver<T>
where
    T: arci::MotorDrivePosition + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(
        self,
    ) -> pb::motor_drive_position_server::MotorDrivePositionServer<Self> {
        pb::motor_drive_position_server::MotorDrivePositionServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
impl arci::MotorDrivePosition for RemoteMotorDrivePositionSender {
    fn set_motor_position(&self, position: f64) -> Result<(), Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(position.into());
        Ok(
            block_in_place(client.set_motor_position(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
    fn get_motor_position(&self) -> Result<f64, Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(());
        Ok(
            block_in_place(client.get_motor_position(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
}
#[tonic::async_trait]
impl<T> pb::motor_drive_position_server::MotorDrivePosition
for RemoteMotorDrivePositionReceiver<T>
where
    T: arci::MotorDrivePosition + 'static,
{
    async fn set_motor_position(
        &self,
        request: tonic::Request<f64>,
    ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::MotorDrivePosition::set_motor_position(
                &self.inner,
                request.into(),
            )
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
    async fn get_motor_position(
        &self,
        request: tonic::Request<()>,
    ) -> std::result::Result<tonic::Response<f64>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::MotorDrivePosition::get_motor_position(&self.inner)
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
}
#[derive(Debug, Clone)]
pub struct RemoteMotorDriveVelocitySender {
    pub(crate) client: pb::motor_drive_velocity_client::MotorDriveVelocityClient<
        tonic::transport::Channel,
    >,
}
impl RemoteMotorDriveVelocitySender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::motor_drive_velocity_client::MotorDriveVelocityClient::connect(
                dst,
            )
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::motor_drive_velocity_client::MotorDriveVelocityClient::new(
                channel,
            ),
        }
    }
}
#[derive(Debug)]
pub struct RemoteMotorDriveVelocityReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteMotorDriveVelocityReceiver<T>
where
    T: arci::MotorDriveVelocity + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(
        self,
    ) -> pb::motor_drive_velocity_server::MotorDriveVelocityServer<Self> {
        pb::motor_drive_velocity_server::MotorDriveVelocityServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
impl arci::MotorDriveVelocity for RemoteMotorDriveVelocitySender {
    fn set_motor_velocity(&self, velocity: f64) -> Result<(), Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(velocity.into());
        Ok(
            block_in_place(client.set_motor_velocity(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
    fn get_motor_velocity(&self) -> Result<f64, Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(());
        Ok(
            block_in_place(client.get_motor_velocity(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
}
#[tonic::async_trait]
impl<T> pb::motor_drive_velocity_server::MotorDriveVelocity
for RemoteMotorDriveVelocityReceiver<T>
where
    T: arci::MotorDriveVelocity + 'static,
{
    async fn set_motor_velocity(
        &self,
        request: tonic::Request<f64>,
    ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::MotorDriveVelocity::set_motor_velocity(
                &self.inner,
                request.into(),
            )
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
    async fn get_motor_velocity(
        &self,
        request: tonic::Request<()>,
    ) -> std::result::Result<tonic::Response<f64>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::MotorDriveVelocity::get_motor_velocity(&self.inner)
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
}
#[derive(Debug, Clone)]
pub struct RemoteMotorDriveEffortSender {
    pub(crate) client: pb::motor_drive_effort_client::MotorDriveEffortClient<
        tonic::transport::Channel,
    >,
}
impl RemoteMotorDriveEffortSender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::motor_drive_effort_client::MotorDriveEffortClient::connect(dst)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::motor_drive_effort_client::MotorDriveEffortClient::new(channel),
        }
    }
}
#[derive(Debug)]
pub struct RemoteMotorDriveEffortReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteMotorDriveEffortReceiver<T>
where
    T: arci::MotorDriveEffort + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(
        self,
    ) -> pb::motor_drive_effort_server::MotorDriveEffortServer<Self> {
        pb::motor_drive_effort_server::MotorDriveEffortServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
impl arci::MotorDriveEffort for RemoteMotorDriveEffortSender {
    fn set_motor_effort(&self, effort: f64) -> Result<(), Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(effort.into());
        Ok(
            block_in_place(client.set_motor_effort(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
    fn get_motor_effort(&self) -> Result<f64, Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(());
        Ok(
            block_in_place(client.get_motor_effort(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
}
#[tonic::async_trait]
impl<T> pb::motor_drive_effort_server::MotorDriveEffort
for RemoteMotorDriveEffortReceiver<T>
where
    T: arci::MotorDriveEffort + 'static,
{
    async fn set_motor_effort(
        &self,
        request: tonic::Request<f64>,
    ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::MotorDriveEffort::set_motor_effort(&self.inner, request.into())
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
    async fn get_motor_effort(
        &self,
        request: tonic::Request<()>,
    ) -> std::result::Result<tonic::Response<f64>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::MotorDriveEffort::get_motor_effort(&self.inner)
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
}
#[derive(Debug, Clone)]
pub struct RemoteMoveBaseSender {
    pub(crate) client: pb::move_base_client::MoveBaseClient<tonic::transport::Channel>,
}
impl RemoteMoveBaseSender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::move_base_client::MoveBaseClient::connect(dst)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::move_base_client::MoveBaseClient::new(channel),
        }
    }
}
#[derive(Debug)]
pub struct RemoteMoveBaseReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteMoveBaseReceiver<T>
where
    T: arci::MoveBase + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(self) -> pb::move_base_server::MoveBaseServer<Self> {
        pb::move_base_server::MoveBaseServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
impl arci::MoveBase for RemoteMoveBaseSender {
    fn send_velocity(&self, velocity: &BaseVelocity) -> Result<(), Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new((*velocity).into());
        Ok(
            block_in_place(client.send_velocity(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
    fn current_velocity(&self) -> Result<BaseVelocity, Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(());
        Ok(
            block_in_place(client.current_velocity(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
}
#[tonic::async_trait]
impl<T> pb::move_base_server::MoveBase for RemoteMoveBaseReceiver<T>
where
    T: arci::MoveBase + 'static,
{
    async fn send_velocity(
        &self,
        request: tonic::Request<pb::BaseVelocity>,
    ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::MoveBase::send_velocity(&self.inner, &request.into())
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
    async fn current_velocity(
        &self,
        request: tonic::Request<()>,
    ) -> std::result::Result<tonic::Response<pb::BaseVelocity>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::MoveBase::current_velocity(&self.inner)
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
}
#[derive(Debug, Clone)]
pub struct RemoteNavigationSender {
    pub(crate) client: pb::navigation_client::NavigationClient<
        tonic::transport::Channel,
    >,
}
impl RemoteNavigationSender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::navigation_client::NavigationClient::connect(dst)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::navigation_client::NavigationClient::new(channel),
        }
    }
}
#[derive(Debug)]
pub struct RemoteNavigationReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteNavigationReceiver<T>
where
    T: arci::Navigation + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(self) -> pb::navigation_server::NavigationServer<Self> {
        pb::navigation_server::NavigationServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
impl arci::Navigation for RemoteNavigationSender {
    fn send_goal_pose(
        &self,
        goal: Isometry2<f64>,
        frame_id: &str,
        timeout: std::time::Duration,
    ) -> Result<WaitFuture, Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new((goal, frame_id, timeout).into());
        Ok(
            wait_from_handle(
                tokio::spawn(async move { client.send_goal_pose(args).await }),
            ),
        )
    }
    fn cancel(&self) -> Result<(), Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(());
        Ok(
            block_in_place(client.cancel(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
}
#[tonic::async_trait]
impl<T> pb::navigation_server::Navigation for RemoteNavigationReceiver<T>
where
    T: arci::Navigation + 'static,
{
    async fn send_goal_pose(
        &self,
        request: tonic::Request<pb::GoalPoseRequest>,
    ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::Navigation::send_goal_pose(
                &self.inner,
                request.goal.unwrap().into(),
                &request.frame_id,
                request.timeout.unwrap().try_into().unwrap(),
            )
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .await
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
    async fn cancel(
        &self,
        request: tonic::Request<()>,
    ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::Navigation::cancel(&self.inner)
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
}
#[derive(Debug, Clone)]
pub struct RemoteSpeakerSender {
    pub(crate) client: pb::speaker_client::SpeakerClient<tonic::transport::Channel>,
}
impl RemoteSpeakerSender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::speaker_client::SpeakerClient::connect(dst)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::speaker_client::SpeakerClient::new(channel),
        }
    }
}
#[derive(Debug)]
pub struct RemoteSpeakerReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteSpeakerReceiver<T>
where
    T: arci::Speaker + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(self) -> pb::speaker_server::SpeakerServer<Self> {
        pb::speaker_server::SpeakerServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
impl arci::Speaker for RemoteSpeakerSender {
    fn speak(&self, message: &str) -> Result<WaitFuture, Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new(message.into());
        Ok(wait_from_handle(tokio::spawn(async move { client.speak(args).await })))
    }
}
#[tonic::async_trait]
impl<T> pb::speaker_server::Speaker for RemoteSpeakerReceiver<T>
where
    T: arci::Speaker + 'static,
{
    async fn speak(
        &self,
        request: tonic::Request<::prost::alloc::string::String>,
    ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::Speaker::speak(&self.inner, &request)
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .await
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
}
#[derive(Debug, Clone)]
pub struct RemoteTransformResolverSender {
    pub(crate) client: pb::transform_resolver_client::TransformResolverClient<
        tonic::transport::Channel,
    >,
}
impl RemoteTransformResolverSender {
    /// Attempt to create a new sender by connecting to a given endpoint.
    pub async fn connect<D>(dst: D) -> Result<Self, arci::Error>
    where
        D: TryInto<tonic::transport::Endpoint>,
        D::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        let client = pb::transform_resolver_client::TransformResolverClient::connect(dst)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(Self { client })
    }
    /// Create a new sender.
    pub fn new(channel: tonic::transport::Channel) -> Self {
        Self {
            client: pb::transform_resolver_client::TransformResolverClient::new(channel),
        }
    }
}
#[derive(Debug)]
pub struct RemoteTransformResolverReceiver<T> {
    pub(crate) inner: T,
}
impl<T> RemoteTransformResolverReceiver<T>
where
    T: arci::TransformResolver + 'static,
{
    /// Create a new receiver.
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
    /// Convert this receiver into a tower service.
    pub fn into_service(
        self,
    ) -> pb::transform_resolver_server::TransformResolverServer<Self> {
        pb::transform_resolver_server::TransformResolverServer::new(self)
    }
    pub async fn serve(self, addr: SocketAddr) -> Result<(), arci::Error> {
        tonic::transport::Server::builder()
            .add_service(self.into_service())
            .serve(addr)
            .await
            .map_err(|e| arci::Error::Connection {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
impl arci::TransformResolver for RemoteTransformResolverSender {
    fn resolve_transformation(
        &self,
        from: &str,
        to: &str,
        time: std::time::SystemTime,
    ) -> Result<Isometry3<f64>, Error> {
        let mut client = self.client.clone();
        let args = tonic::Request::new((from, to, time).into());
        Ok(
            block_in_place(client.resolve_transformation(args))
                .map_err(|e| arci::Error::Other(e.into()))?
                .into_inner()
                .into(),
        )
    }
}
#[tonic::async_trait]
impl<T> pb::transform_resolver_server::TransformResolver
for RemoteTransformResolverReceiver<T>
where
    T: arci::TransformResolver + 'static,
{
    async fn resolve_transformation(
        &self,
        request: tonic::Request<pb::ResolveTransformationRequest>,
    ) -> std::result::Result<tonic::Response<pb::Isometry3>, tonic::Status> {
        let request = request.into_inner();
        let res = arci::TransformResolver::resolve_transformation(
                &self.inner,
                &request.from,
                &request.to,
                request.time.unwrap().try_into().unwrap(),
            )
            .map_err(|e| tonic::Status::unknown(e.to_string()))?
            .into();
        Ok(tonic::Response::new(res))
    }
}
impl From<arci::TrajectoryPoint> for pb::TrajectoryPoint {
    fn from(v: arci::TrajectoryPoint) -> Self {
        let arci::TrajectoryPoint { positions, velocities, time_from_start } = v;
        Self {
            positions,
            velocities: velocities.unwrap_or_default(),
            time_from_start: Some(time_from_start.try_into().unwrap()),
        }
    }
}
impl From<pb::TrajectoryPoint> for arci::TrajectoryPoint {
    fn from(v: pb::TrajectoryPoint) -> Self {
        let pb::TrajectoryPoint { positions, velocities, time_from_start } = v;
        Self {
            positions,
            velocities: if velocities.is_empty() { None } else { Some(velocities) },
            time_from_start: time_from_start.unwrap().try_into().unwrap(),
        }
    }
}
impl From<arci::Scan2D> for pb::Scan2D {
    fn from(v: arci::Scan2D) -> Self {
        let arci::Scan2D {
            angle_min,
            angle_max,
            angle_increment,
            time_increment,
            scan_time,
            range_min,
            range_max,
            ranges,
            intensities,
        } = v;
        Self {
            angle_min,
            angle_max,
            angle_increment,
            time_increment,
            scan_time,
            range_min,
            range_max,
            ranges,
            intensities,
        }
    }
}
impl From<pb::Scan2D> for arci::Scan2D {
    fn from(v: pb::Scan2D) -> Self {
        let pb::Scan2D {
            angle_min,
            angle_max,
            angle_increment,
            time_increment,
            scan_time,
            range_min,
            range_max,
            ranges,
            intensities,
        } = v;
        Self {
            angle_min,
            angle_max,
            angle_increment,
            time_increment,
            scan_time,
            range_min,
            range_max,
            ranges,
            intensities,
        }
    }
}
impl From<arci::BaseVelocity> for pb::BaseVelocity {
    fn from(v: arci::BaseVelocity) -> Self {
        let arci::BaseVelocity { x, y, theta } = v;
        Self { x, y, theta }
    }
}
impl From<pb::BaseVelocity> for arci::BaseVelocity {
    fn from(v: pb::BaseVelocity) -> Self {
        let pb::BaseVelocity { x, y, theta } = v;
        Self { x, y, theta }
    }
}
impl From<arci::gamepad::Button> for pb::Button {
    fn from(v: arci::gamepad::Button) -> Self {
        match v {
            arci::gamepad::Button::South => Self::South,
            arci::gamepad::Button::East => Self::East,
            arci::gamepad::Button::North => Self::North,
            arci::gamepad::Button::West => Self::West,
            arci::gamepad::Button::LeftTrigger => Self::LeftTrigger,
            arci::gamepad::Button::LeftTrigger2 => Self::LeftTrigger2,
            arci::gamepad::Button::RightTrigger => Self::RightTrigger,
            arci::gamepad::Button::RightTrigger2 => Self::RightTrigger2,
            arci::gamepad::Button::Select => Self::Select,
            arci::gamepad::Button::Start => Self::Start,
            arci::gamepad::Button::Mode => Self::Mode,
            arci::gamepad::Button::LeftThumb => Self::LeftThumb,
            arci::gamepad::Button::RightThumb => Self::RightThumb,
            arci::gamepad::Button::DPadUp => Self::DPadUp,
            arci::gamepad::Button::DPadDown => Self::DPadDown,
            arci::gamepad::Button::DPadLeft => Self::DPadLeft,
            arci::gamepad::Button::DPadRight => Self::DPadRight,
            arci::gamepad::Button::Unknown => Self::Unknown,
        }
    }
}
impl From<pb::Button> for arci::gamepad::Button {
    fn from(v: pb::Button) -> Self {
        match v {
            pb::Button::South => Self::South,
            pb::Button::East => Self::East,
            pb::Button::North => Self::North,
            pb::Button::West => Self::West,
            pb::Button::LeftTrigger => Self::LeftTrigger,
            pb::Button::LeftTrigger2 => Self::LeftTrigger2,
            pb::Button::RightTrigger => Self::RightTrigger,
            pb::Button::RightTrigger2 => Self::RightTrigger2,
            pb::Button::Select => Self::Select,
            pb::Button::Start => Self::Start,
            pb::Button::Mode => Self::Mode,
            pb::Button::LeftThumb => Self::LeftThumb,
            pb::Button::RightThumb => Self::RightThumb,
            pb::Button::DPadUp => Self::DPadUp,
            pb::Button::DPadDown => Self::DPadDown,
            pb::Button::DPadLeft => Self::DPadLeft,
            pb::Button::DPadRight => Self::DPadRight,
            pb::Button::Unknown => Self::Unknown,
        }
    }
}
impl From<arci::gamepad::Axis> for pb::Axis {
    fn from(v: arci::gamepad::Axis) -> Self {
        match v {
            arci::gamepad::Axis::LeftStickX => Self::LeftStickX,
            arci::gamepad::Axis::LeftStickY => Self::LeftStickY,
            arci::gamepad::Axis::LeftTrigger => Self::LeftTrigger,
            arci::gamepad::Axis::RightStickX => Self::RightStickX,
            arci::gamepad::Axis::RightStickY => Self::RightStickY,
            arci::gamepad::Axis::RightTrigger => Self::RightTrigger,
            arci::gamepad::Axis::DPadX => Self::DPadX,
            arci::gamepad::Axis::DPadY => Self::DPadY,
            arci::gamepad::Axis::Unknown => Self::Unknown,
        }
    }
}
impl From<pb::Axis> for arci::gamepad::Axis {
    fn from(v: pb::Axis) -> Self {
        match v {
            pb::Axis::LeftStickX => Self::LeftStickX,
            pb::Axis::LeftStickY => Self::LeftStickY,
            pb::Axis::LeftTrigger => Self::LeftTrigger,
            pb::Axis::RightStickX => Self::RightStickX,
            pb::Axis::RightStickY => Self::RightStickY,
            pb::Axis::RightTrigger => Self::RightTrigger,
            pb::Axis::DPadX => Self::DPadX,
            pb::Axis::DPadY => Self::DPadY,
            pb::Axis::Unknown => Self::Unknown,
        }
    }
}
