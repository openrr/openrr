<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A simple, safe HTTP client."><title>ureq - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ureq" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ureq/index.html">ureq</a><span class="version">2.12.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#error-handling" title="Error handling">Error handling</a></li><li><a href="#features" title="Features">Features</a></li><li><a href="#plain-requests" title="Plain requests">Plain requests</a></li><li><a href="#json" title="JSON">JSON</a></li><li><a href="#content-length-and-transfer-encoding" title="Content-Length and Transfer-Encoding">Content-Length and Transfer-Encoding</a></li><li><a href="#character-encoding" title="Character encoding">Character encoding</a></li><li><a href="#proxying" title="Proxying">Proxying</a><ul><li><a href="#example-using-http" title="Example using HTTP">Example using HTTP</a></li><li><a href="#example-using-socks5" title="Example using SOCKS5">Example using SOCKS5</a></li></ul></li><li><a href="#https--tls--ssl" title="HTTPS / TLS / SSL">HTTPS / TLS / SSL</a><ul><li><a href="#trusted-roots" title="Trusted Roots">Trusted Roots</a></li></ul></li><li><a href="#blocking-io-for-simplicity" title="Blocking I/O for simplicity">Blocking I/O for simplicity</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>ureq</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/ureq/lib.rs.html#1-646">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><div align="center">
  <!-- Version -->
  <a href="https://crates.io/crates/ureq">
    <img src="https://img.shields.io/crates/v/ureq.svg?style=flat-square"
    alt="Crates.io version" />
  </a>
  <!-- Docs -->
  <a href="https://docs.rs/ureq">
    <img src="https://img.shields.io/badge/docs-latest-blue.svg?style=flat-square"
      alt="docs.rs docs" />
  </a>
  <!-- Downloads -->
  <a href="https://crates.io/crates/ureq">
    <img src="https://img.shields.io/crates/d/ureq.svg?style=flat-square"
      alt="Crates.io downloads" />
  </a>
</div>
<p>A simple, safe HTTP client.</p>
<blockquote>
<p>[!NOTE]</p>
<ul>
<li>2.12.x is MSRV 1.71</li>
<li>2.11.x is MSRV 1.67</li>
</ul>
<p>For both these lines, we will release patch version pinning dependencies as needed to
retain the MSRV. If we are bumping MSRV, that will require a minor version bump.</p>
</blockquote>
<blockquote>
<p>[!NOTE]
ureq version 2.11.0 was forced to bump MSRV from 1.63 -&gt; 1.67. The problem is that the
<code>time</code> crate 0.3.20, the last 1.63 compatible version, stopped compiling with Rust
<a href="https://github.com/algesten/ureq/pull/878#issuecomment-2503176155">1.80 and above</a>.
To release a 2.x version that is possible to compile on the latest Rust we were
forced to bump MSRV.</p>
</blockquote>
<p>Ureq’s first priority is being easy for you to use. It’s great for
anyone who wants a low-overhead HTTP client that just gets the job done. Works
very well with HTTP APIs. Its features include cookies, JSON, HTTP proxies,
HTTPS, interoperability with the <code>http</code> crate, and charset decoding.</p>
<p>Ureq is in pure Rust for safety and ease of understanding. It avoids using
<code>unsafe</code> directly. It <a href="#blocking-io-for-simplicity">uses blocking I/O</a> instead of async I/O, because that keeps
the API simple and keeps dependencies to a minimum. For TLS, ureq uses
<a href="#https--tls--ssl">rustls or native-tls</a>.</p>
<p>See the <a href="https://github.com/algesten/ureq/blob/main/CHANGELOG.md">changelog</a> for details of recent releases.</p>
<h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3>
<p>In its simplest form, ureq looks like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), ureq::Error&gt; {
    <span class="kw">let </span>body: String = ureq::get(<span class="string">"http://example.com"</span>)
        .set(<span class="string">"Example-Header"</span>, <span class="string">"header value"</span>)
        .call()<span class="question-mark">?
        </span>.into_string()<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>For more involved tasks, you’ll want to create an <a href="struct.Agent.html" title="struct ureq::Agent">Agent</a>. An Agent
holds a connection pool for reuse, and a cookie store if you use the
“cookies” feature. An Agent can be cheaply cloned due to an internal
<a href="https://doc.rust-lang.org/1.90.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a> and all clones of an Agent share state among each other. Creating
an Agent also allows setting options like the TLS configuration.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="kw">use </span>ureq::{Agent, AgentBuilder};
  <span class="kw">use </span>std::time::Duration;

  <span class="kw">let </span>agent: Agent = ureq::AgentBuilder::new()
      .timeout_read(Duration::from_secs(<span class="number">5</span>))
      .timeout_write(Duration::from_secs(<span class="number">5</span>))
      .build();
  <span class="kw">let </span>body: String = agent.get(<span class="string">"http://example.com/page"</span>)
      .call()<span class="question-mark">?
      </span>.into_string()<span class="question-mark">?</span>;

  <span class="comment">// Reuses the connection from previous request.
  </span><span class="kw">let </span>response: String = agent.put(<span class="string">"http://example.com/upload"</span>)
      .set(<span class="string">"Authorization"</span>, <span class="string">"example-token"</span>)
      .call()<span class="question-mark">?
      </span>.into_string()<span class="question-mark">?</span>;</code></pre></div>
<p>Ureq supports sending and receiving json, if you enable the “json” feature:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Requires the `json` feature enabled.
  </span><span class="kw">let </span>resp: String = ureq::post(<span class="string">"http://myapi.example.com/post/ingest"</span>)
      .set(<span class="string">"X-My-Header"</span>, <span class="string">"Secret"</span>)
      .send_json(<span class="macro">ureq::json!</span>({
          <span class="string">"name"</span>: <span class="string">"martin"</span>,
          <span class="string">"rust"</span>: <span class="bool-val">true
      </span>}))<span class="question-mark">?
      </span>.into_string()<span class="question-mark">?</span>;</code></pre></div>
<h3 id="error-handling"><a class="doc-anchor" href="#error-handling">§</a>Error handling</h3>
<p>ureq returns errors via <code>Result&lt;T, ureq::Error&gt;</code>. That includes I/O errors,
protocol errors, and status code errors (when the server responded 4xx or
5xx)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ureq::Error;

<span class="kw">match </span>ureq::get(<span class="string">"http://mypage.example.com/"</span>).call() {
    <span class="prelude-val">Ok</span>(response) =&gt; { <span class="comment">/* it worked */</span>},
    <span class="prelude-val">Err</span>(Error::Status(code, response)) =&gt; {
        <span class="comment">/* the server returned an unexpected status
           code (such as 400, 500 etc) */
    </span>}
    <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; { <span class="comment">/* some kind of io/transport error */ </span>}
}</code></pre></div>
<p>More details on the <a href="enum.Error.html" title="enum ureq::Error">Error</a> type.</p>
<h3 id="features"><a class="doc-anchor" href="#features">§</a>Features</h3>
<p>To enable a minimal dependency tree, some features are off by default.
You can control them when including ureq as a dependency.</p>
<p><code>ureq = { version = "*", features = ["json", "charset"] }</code></p>
<ul>
<li><code>tls</code> enables https. This is enabled by default.</li>
<li><code>native-certs</code> makes the default TLS implementation use the OS’ trust store (see TLS doc below).</li>
<li><code>cookies</code> enables cookies.</li>
<li><code>json</code> enables <a href="struct.Response.html#method.into_json" title="method ureq::Response::into_json">Response::into_json()</a> and <a href="struct.Request.html#method.send_json" title="method ureq::Request::send_json">Request::send_json()</a> via serde_json.</li>
<li><code>charset</code> enables interpreting the charset part of the Content-Type header
(e.g.  <code>Content-Type: text/plain; charset=iso-8859-1</code>). Without this, the
library defaults to Rust’s built in <code>utf-8</code>.</li>
<li><code>socks-proxy</code> enables proxy config using the <code>socks4://</code>, <code>socks4a://</code>, <code>socks5://</code> and <code>socks://</code> (equal to <code>socks5://</code>) prefix.</li>
<li><code>native-tls</code> enables an adapter so you can pass a <code>native_tls::TlsConnector</code> instance
to <code>AgentBuilder::tls_connector</code>. Due to the risk of diamond dependencies accidentally switching on an unwanted
TLS implementation, <code>native-tls</code> is never picked up as a default or used by the crate level
convenience calls (<code>ureq::get</code> etc) – it must be configured on the agent. The <code>native-certs</code> feature
does nothing for <code>native-tls</code>.</li>
<li><code>gzip</code> enables requests of gzip-compressed responses and decompresses them. This is enabled by default.</li>
<li><code>brotli</code> enables requests brotli-compressed responses and decompresses them.</li>
<li><code>http-interop</code> enables conversion methods to and from <code>http::Response</code> and <code>http::request::Builder</code> (v0.2).</li>
<li><code>http</code> enables conversion methods to and from <code>http::Response</code> and <code>http::request::Builder</code> (v1.0).</li>
</ul>
<h2 id="plain-requests"><a class="doc-anchor" href="#plain-requests">§</a>Plain requests</h2>
<p>Most standard methods (GET, POST, PUT etc), are supported as functions from the
top of the library (<a href="fn.get.html" title="fn ureq::get">get()</a>, <a href="fn.post.html" title="fn ureq::post">post()</a>, <a href="fn.put.html" title="fn ureq::put">put()</a>, etc).</p>
<p>These top level http method functions create a <a href="struct.Request.html" title="struct ureq::Request">Request</a> instance
which follows a build pattern. The builders are finished using:</p>
<ul>
<li><a href="struct.Request.html#method.call" title="method ureq::Request::call"><code>.call()</code></a> without a request body.</li>
<li><a href="struct.Request.html#method.send" title="method ureq::Request::send"><code>.send()</code></a> with a request body as <a href="https://doc.rust-lang.org/1.90.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> (chunked encoding support for non-known sized readers).</li>
<li><a href="struct.Request.html#method.send_string" title="method ureq::Request::send_string"><code>.send_string()</code></a> body as string.</li>
<li><a href="struct.Request.html#method.send_bytes" title="method ureq::Request::send_bytes"><code>.send_bytes()</code></a> body as bytes.</li>
<li><a href="struct.Request.html#method.send_form" title="method ureq::Request::send_form"><code>.send_form()</code></a> key-value pairs as application/x-www-form-urlencoded.</li>
</ul>
<h2 id="json"><a class="doc-anchor" href="#json">§</a>JSON</h2>
<p>By enabling the <code>ureq = { version = "*", features = ["json"] }</code> feature,
the library supports serde json.</p>
<ul>
<li><a href="struct.Request.html#method.send_json" title="method ureq::Request::send_json"><code>request.send_json()</code></a> send body as serde json.</li>
<li><a href="struct.Response.html#method.into_json" title="method ureq::Response::into_json"><code>response.into_json()</code></a> transform response to json.</li>
</ul>
<h2 id="content-length-and-transfer-encoding"><a class="doc-anchor" href="#content-length-and-transfer-encoding">§</a>Content-Length and Transfer-Encoding</h2>
<p>The library will send a Content-Length header on requests with bodies of
known size, in other words, those sent with
<a href="struct.Request.html#method.send_string" title="method ureq::Request::send_string"><code>.send_string()</code></a>,
<a href="struct.Request.html#method.send_bytes" title="method ureq::Request::send_bytes"><code>.send_bytes()</code></a>,
<a href="struct.Request.html#method.send_form" title="method ureq::Request::send_form"><code>.send_form()</code></a>, or
<a href="struct.Request.html#method.send_json" title="method ureq::Request::send_json"><code>.send_json()</code></a>. If you send a
request body with <a href="struct.Request.html#method.send" title="method ureq::Request::send"><code>.send()</code></a>,
which takes a <a href="https://doc.rust-lang.org/1.90.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> of unknown size, ureq will send Transfer-Encoding:
chunked, and encode the body accordingly. Bodyless requests
(GETs and HEADs) are sent with <a href="struct.Request.html#method.call" title="method ureq::Request::call"><code>.call()</code></a>
and ureq adds neither a Content-Length nor a Transfer-Encoding header.</p>
<p>If you set your own Content-Length or Transfer-Encoding header before
sending the body, ureq will respect that header by not overriding it,
and by encoding the body or not, as indicated by the headers you set.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resp = ureq::post(<span class="string">"http://my-server.com/ingest"</span>)
    .set(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)
    .send_string(<span class="string">"Hello world"</span>);</code></pre></div>
<h2 id="character-encoding"><a class="doc-anchor" href="#character-encoding">§</a>Character encoding</h2>
<p>By enabling the <code>ureq = { version = "*", features = ["charset"] }</code> feature,
the library supports sending/receiving other character sets than <code>utf-8</code>.</p>
<p>For <a href="struct.Response.html#method.into_string" title="method ureq::Response::into_string"><code>response.into_string()</code></a> we read the
header <code>Content-Type: text/plain; charset=iso-8859-1</code> and if it contains a charset
specification, we try to decode the body using that encoding. In the absence of, or failing
to interpret the charset, we fall back on <code>utf-8</code>.</p>
<p>Similarly when using <a href="struct.Request.html#method.send_string" title="method ureq::Request::send_string"><code>request.send_string()</code></a>,
we first check if the user has set a <code>; charset=&lt;whatwg charset&gt;</code> and attempt
to encode the request body using that.</p>
<h2 id="proxying"><a class="doc-anchor" href="#proxying">§</a>Proxying</h2>
<p>ureq supports two kinds of proxies,  <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Proxy_servers_and_tunneling#http_tunneling"><code>HTTP</code></a> (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT"><code>CONNECT</code></a>), <a href="https://en.wikipedia.org/wiki/SOCKS#SOCKS4"><code>SOCKS4</code></a> and <a href="https://en.wikipedia.org/wiki/SOCKS#SOCKS5"><code>SOCKS5</code></a>,
the former is always available while the latter must be enabled using the feature
<code>ureq = { version = "*", features = ["socks-proxy"] }</code>.</p>
<p>Proxies settings are configured on an <a href="struct.Agent.html" title="struct ureq::Agent">Agent</a> (using <a href="struct.AgentBuilder.html" title="struct ureq::AgentBuilder">AgentBuilder</a>). All request sent
through the agent will be proxied.</p>
<h3 id="example-using-http"><a class="doc-anchor" href="#example-using-http">§</a>Example using HTTP</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>proxy_example_1() -&gt; std::result::Result&lt;(), ureq::Error&gt; {
    <span class="comment">// Configure an http connect proxy. Notice we could have used
    // the http:// prefix here (it's optional).
    </span><span class="kw">let </span>proxy = ureq::Proxy::new(<span class="string">"user:password@cool.proxy:9090"</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span>agent = ureq::AgentBuilder::new()
        .proxy(proxy)
        .build();

    <span class="comment">// This is proxied.
    </span><span class="kw">let </span>resp = agent.get(<span class="string">"http://cool.server"</span>).call()<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="example-using-socks5"><a class="doc-anchor" href="#example-using-socks5">§</a>Example using SOCKS5</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>proxy_example_2() -&gt; std::result::Result&lt;(), ureq::Error&gt; {
    <span class="comment">// Configure a SOCKS proxy.
    </span><span class="kw">let </span>proxy = ureq::Proxy::new(<span class="string">"socks5://user:password@cool.proxy:9090"</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span>agent = ureq::AgentBuilder::new()
        .proxy(proxy)
        .build();

    <span class="comment">// This is proxied.
    </span><span class="kw">let </span>resp = agent.get(<span class="string">"http://cool.server"</span>).call()<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h2 id="https--tls--ssl"><a class="doc-anchor" href="#https--tls--ssl">§</a>HTTPS / TLS / SSL</h2>
<p>On platforms that support rustls, ureq uses rustls. On other platforms, native-tls can
be manually configured using <a href="struct.AgentBuilder.html#method.tls_connector" title="method ureq::AgentBuilder::tls_connector"><code>AgentBuilder::tls_connector</code></a>.</p>
<p>You might want to use native-tls if you need to interoperate with servers that
only support less-secure TLS configurations (rustls doesn’t support TLS 1.0 and 1.1, for
instance). You might also want to use it if you need to validate certificates for IP addresses,
which are not currently supported in rustls.</p>
<p>Here’s an example of constructing an Agent that uses native-tls. It requires the
“native-tls” feature to be enabled.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="kw">use </span>std::sync::Arc;
  <span class="kw">use </span>ureq::Agent;

  <span class="kw">let </span>agent = ureq::AgentBuilder::new()
      .tls_connector(Arc::new(native_tls::TlsConnector::new()<span class="question-mark">?</span>))
      .build();</code></pre></div>
<h3 id="trusted-roots"><a class="doc-anchor" href="#trusted-roots">§</a>Trusted Roots</h3>
<p>When you use rustls (<code>tls</code> feature), ureq defaults to trusting
<a href="https://docs.rs/webpki-roots/">webpki-roots</a>, a
copy of the Mozilla Root program that is bundled into your program (and so won’t update if your
program isn’t updated). You can alternately configure
<a href="https://docs.rs/rustls-native-certs/">rustls-native-certs</a> which extracts the roots from your
OS’ trust store. That means it will update when your OS is updated, and also that it will
include locally installed roots.</p>
<p>When you use <code>native-tls</code>, ureq will use your OS’ certificate verifier and root store.</p>
<h2 id="blocking-io-for-simplicity"><a class="doc-anchor" href="#blocking-io-for-simplicity">§</a>Blocking I/O for simplicity</h2>
<p>Ureq uses blocking I/O rather than Rust’s newer <a href="https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html">asynchronous (async) I/O</a>. Async I/O
allows serving many concurrent requests without high costs in memory and OS threads. But
it comes at a cost in complexity. Async programs need to pull in a runtime (usually
<a href="https://github.com/async-rs/async-std#async-std">async-std</a> or <a href="https://github.com/tokio-rs/tokio#tokio">tokio</a>). They also need async variants of any method that might block, and of
<a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">any method that might call another method that might block</a>. That means async
programs usually have a lot of dependencies - which adds to compile times, and increases
risk.</p>
<p>The costs of async are worth paying, if you’re writing an HTTP server that must serve
many many clients with minimal overhead. However, for HTTP <em>clients</em>, we believe that the
cost is usually not worth paying. The low-cost alternative to async I/O is blocking I/O,
which has a different price: it requires an OS thread per concurrent request. However,
that price is usually not high: most HTTP clients make requests sequentially, or with
low concurrency.</p>
<p>That’s why ureq uses blocking I/O and plans to stay that way. Other HTTP clients offer both
an async API and a blocking API, but we want to offer a blocking API without pulling in all
the dependencies required by an async API.</p>
<hr />
<p>Ureq is inspired by other great HTTP clients like
<a href="http://visionmedia.github.io/superagent/">superagent</a> and
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">the fetch API</a>.</p>
<p>If ureq is not what you’re looking for, check out these other Rust HTTP clients:
<a href="https://crates.io/crates/surf">surf</a>, <a href="https://crates.io/crates/reqwest">reqwest</a>,
<a href="https://crates.io/crates/isahc">isahc</a>, <a href="https://crates.io/crates/attohttpc">attohttpc</a>,
<a href="https://crates.io/crates/actix-web">actix-web</a>, and <a href="https://crates.io/crates/hyper">hyper</a>.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.rustls"><code>pub use <a class="mod" href="../rustls/index.html" title="mod rustls">rustls</a>;</code></dt><dt id="reexport.serde"><code>pub use <a class="mod" href="../serde/index.html" title="mod serde">serde</a>;</code></dt><dt id="reexport.serde_json"><code>pub use <a class="mod" href="../serde_json/index.html" title="mod serde_json">serde_json</a>;</code></dt></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.json.html" title="macro ureq::json">json</a></dt><dd>Construct a <code>serde_json::Value</code> from a JSON literal.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Agent.html" title="struct ureq::Agent">Agent</a></dt><dd>Agents keep state between requests.</dd><dt><a class="struct" href="struct.AgentBuilder.html" title="struct ureq::AgentBuilder">Agent<wbr>Builder</a></dt><dd>Accumulates options towards building an <a href="struct.Agent.html" title="struct ureq::Agent">Agent</a>.</dd><dt><a class="struct" href="struct.MiddlewareNext.html" title="struct ureq::MiddlewareNext">Middleware<wbr>Next</a></dt><dd>Continuation of a <a href="trait.Middleware.html" title="trait ureq::Middleware"><code>Middleware</code></a> chain.</dd><dt><a class="struct" href="struct.Proxy.html" title="struct ureq::Proxy">Proxy</a></dt><dd>Proxy server definition</dd><dt><a class="struct" href="struct.Request.html" title="struct ureq::Request">Request</a></dt><dd>Request instances are builders that creates a request.</dd><dt><a class="struct" href="struct.RequestUrl.html" title="struct ureq::RequestUrl">Request<wbr>Url</a></dt><dd>Parsed result of a request url with handy inspection methods.</dd><dt><a class="struct" href="struct.Response.html" title="struct ureq::Response">Response</a></dt><dd>Response instances are created as results of firing off requests.</dd><dt><a class="struct" href="struct.Transport.html" title="struct ureq::Transport">Transport</a></dt><dd>Error that is not a status code error. For instance, DNS name not found,
connection refused, or malformed response.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Error.html" title="enum ureq::Error">Error</a></dt><dd>An error that may occur when processing a <a href="struct.Request.html" title="struct ureq::Request">Request</a>.</dd><dt><a class="enum" href="enum.ErrorKind.html" title="enum ureq::ErrorKind">Error<wbr>Kind</a></dt><dd>One of the types of error the can occur when processing a Request.</dd><dt><a class="enum" href="enum.RedirectAuthHeaders.html" title="enum ureq::RedirectAuthHeaders">Redirect<wbr>Auth<wbr>Headers</a></dt><dd>Strategy for keeping <code>authorization</code> headers during redirects.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Middleware.html" title="trait ureq::Middleware">Middleware</a></dt><dd>Chained processing of request (and response).</dd><dt><a class="trait" href="trait.OrAnyStatus.html" title="trait ureq::OrAnyStatus">OrAny<wbr>Status</a></dt><dd>Extension to <a href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result&lt;Response, Error&gt;</code></a> for handling all status codes as <a href="struct.Response.html" title="struct ureq::Response"><code>Response</code></a>.</dd><dt><a class="trait" href="trait.ReadWrite.html" title="trait ureq::ReadWrite">Read<wbr>Write</a></dt><dd>Trait for things implementing <a href="https://doc.rust-lang.org/1.90.0/std/io/trait.Read.html" title="trait std::io::Read">std::io::Read</a> + <a href="https://doc.rust-lang.org/1.90.0/std/io/trait.Write.html" title="trait std::io::Write">std::io::Write</a>. Used in <a href="trait.TlsConnector.html" title="trait ureq::TlsConnector">TlsConnector</a>.</dd><dt><a class="trait" href="trait.Resolver.html" title="trait ureq::Resolver">Resolver</a></dt><dd>A custom resolver to override the default DNS behavior.</dd><dt><a class="trait" href="trait.TlsConnector.html" title="trait ureq::TlsConnector">TlsConnector</a></dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.agent.html" title="fn ureq::agent">agent</a></dt><dd>Agents are used to hold configuration and keep state between requests.</dd><dt><a class="fn" href="fn.builder.html" title="fn ureq::builder">builder</a></dt><dd>Creates an <a href="struct.AgentBuilder.html" title="struct ureq::AgentBuilder">AgentBuilder</a>.</dd><dt><a class="fn" href="fn.delete.html" title="fn ureq::delete">delete</a></dt><dd>Make a DELETE request.</dd><dt><a class="fn" href="fn.get.html" title="fn ureq::get">get</a></dt><dd>Make a GET request.</dd><dt><a class="fn" href="fn.head.html" title="fn ureq::head">head</a></dt><dd>Make a HEAD request.</dd><dt><a class="fn" href="fn.patch.html" title="fn ureq::patch">patch</a></dt><dd>Make a PATCH request.</dd><dt><a class="fn" href="fn.post.html" title="fn ureq::post">post</a></dt><dd>Make a POST request.</dd><dt><a class="fn" href="fn.put.html" title="fn ureq::put">put</a></dt><dd>Make a PUT request.</dd><dt><a class="fn" href="fn.request.html" title="fn ureq::request">request</a></dt><dd>Make a request with the HTTP verb as a parameter.</dd><dt><a class="fn" href="fn.request_url.html" title="fn ureq::request_url">request_<wbr>url</a></dt><dd>Make a request using an already-parsed <a href="../url/struct.Url.html" title="struct url::Url">Url</a>.</dd><dt><a class="fn" href="fn.serde_to_value.html" title="fn ureq::serde_to_value">serde_<wbr>to_<wbr>value</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.SerdeMap.html" title="type ureq::SerdeMap">Serde<wbr>Map</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dt><a class="type" href="type.SerdeValue.html" title="type ureq::SerdeValue">Serde<wbr>Value</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt></dl></section></div></main></body></html>