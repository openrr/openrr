<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Parsing C literals from byte slices."><title>cexpr::literal - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="cexpr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../cexpr/index.html">cexpr</a><span class="version">0.6.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module literal</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#characters" title="characters">characters</a></li><li><a href="#strings" title="strings">strings</a></li><li><a href="#integers" title="integers">integers</a></li><li><a href="#real-numbers" title="real numbers">real numbers</a></li></ul><h3><a href="#enums">Module Items</a></h3><ul class="block"><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate cexpr</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">cexpr</a></div><h1>Module <span>literal</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/cexpr/literal.rs.html#8-361">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Parsing C literals from byte slices.</p>
<p>This will parse a representation of a C literal into a Rust type.</p>
<h2 id="characters"><a class="doc-anchor" href="#characters">§</a>characters</h2>
<p>Character literals are stored into the <code>CChar</code> type, which can hold values
that are not valid Unicode code points. ASCII characters are represented as
<code>char</code>, literal bytes with the high byte set are converted into the raw
representation. Escape sequences are supported. If hex and octal escapes
map to an ASCII character, that is used, otherwise, the raw encoding is
used, including for values over 255. Unicode escapes are checked for
validity and mapped to <code>char</code>. Character sequences are not supported. Width
prefixes are ignored.</p>
<h2 id="strings"><a class="doc-anchor" href="#strings">§</a>strings</h2>
<p>Strings are interpreted as byte vectors. Escape sequences are supported. If
hex and octal escapes map onto multi-byte characters, they are truncated to
one 8-bit character. Unicode escapes are converted into their UTF-8
encoding. Width prefixes are ignored.</p>
<h2 id="integers"><a class="doc-anchor" href="#integers">§</a>integers</h2>
<p>Integers are read into <code>i64</code>. Binary, octal, decimal and hexadecimal are
all supported. If the literal value is between <code>i64::MAX</code> and <code>u64::MAX</code>,
it is bit-cast to <code>i64</code>. Values over <code>u64::MAX</code> cannot be parsed. Width and
sign suffixes are ignored. Sign prefixes are not supported.</p>
<h2 id="real-numbers"><a class="doc-anchor" href="#real-numbers">§</a>real numbers</h2>
<p>Reals are read into <code>f64</code>. Width suffixes are ignored. Sign prefixes are
not supported in the significand. Hexadecimal floating points are not
supported.</p>
</div></details><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.CChar.html" title="enum cexpr::literal::CChar">CChar</a></dt><dd>Representation of a C character</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.full.html" title="fn cexpr::literal::full">full</a></dt><dd>ensures the child parser consumes the whole input</dd><dt><a class="fn" href="fn.parse.html" title="fn cexpr::literal::parse">parse</a></dt><dd>Parse a C literal.</dd></dl></section></div></main></body></html>